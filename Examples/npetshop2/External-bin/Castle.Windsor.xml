<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.Windsor</name>
    </assembly>
    <members>
        <member name="T:antlr.collections.AST">
            <summary>
            Minimal AST node interface used by ANTLR AST generation and tree-walker.
            </summary>
        </member>
        <member name="M:antlr.collections.AST.addChild(antlr.collections.AST)">
            <summary>
            Add a (rightmost) child to this node
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:antlr.collections.AST.getFirstChild">
            <summary>
            Get the first child of this node; null if no children
            </summary>
        </member>
        <member name="M:antlr.collections.AST.getNextSibling">
            <summary>
            Get	the next sibling in line after this one
            </summary>
        </member>
        <member name="M:antlr.collections.AST.getText">
            <summary>
            Get the token text for this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:antlr.collections.AST.getNumberOfChildren">
            <summary>
            Get number of children of this node; if leaf, returns 0
            </summary>
            <returns>Number of children</returns>
        </member>
        <member name="M:antlr.collections.AST.setFirstChild(antlr.collections.AST)">
            <summary>
            Set the first child of a node.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:antlr.collections.AST.setNextSibling(antlr.collections.AST)">
            <summary>
            Set the next sibling after this one.
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:antlr.collections.AST.setText(System.String)">
            <summary>
            Set the token text for this node
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:antlr.collections.AST.setType(System.Int32)">
            <summary>
            Set the token type for this node
            </summary>
            <param name="ttype"></param>
        </member>
        <member name="P:antlr.collections.AST.Type">
            <summary>
            Get the token type for this node
            </summary>
        </member>
        <member name="T:antlr.ASTFactory">
            <summary>
            AST Support code shared by TreeParser and Parser.
            </summary>
            <remarks>
            <para>
            We use delegation to share code (and have only one 
            bit of code to maintain) rather than subclassing
            or superclassing (forces AST support code to be
            loaded even when you don't want to do AST stuff).
            </para>
            <para>
            Typically, <see cref="M:antlr.ASTFactory.setASTNodeType(System.String)"/>  is used to specify the
            homogeneous type of node to create, but you can override
            <see cref="M:antlr.ASTFactory.create"/>  to make heterogeneous nodes etc...
            </para>
            </remarks>
        </member>
        <member name="M:antlr.ASTFactory.#ctor">
            <summary>
            Constructs an <c>ASTFactory</c> with the default AST node type of
            <see cref="T:antlr.CommonAST"/>.
            </summary>
        </member>
        <member name="M:antlr.ASTFactory.#ctor(System.String)">
            <summary>
            Constructs an <c>ASTFactory</c> and use the specified AST node type
            as the default.
            </summary>
            <param name="nodeTypeName">
            	Name of default AST node type for this factory.
            </param>
        </member>
        <member name="F:antlr.ASTFactory.defaultASTNodeTypeObject_">
            <summary>
            Stores the Type of the default AST node class to be used during tree construction.
            </summary>
        </member>
        <member name="F:antlr.ASTFactory.heteroList_">
            <summary>
            Stores the mapping between custom AST NodeTypes and their NodeTypeName/NodeTypeClass
            and ASTNodeCreator.
            </summary>
        </member>
        <member name="F:antlr.ASTFactory.typename2creator_">
            <summary>
            Stores the mapping between AST node typenames and their token ID.
            </summary>
        </member>
        <member name="M:antlr.ASTFactory.setTokenTypeASTNodeType(System.Int32,System.String)">
            <summary>
            Specify an "override" for the <see cref="T:antlr.collections.AST"/> type created for
            the specified Token type.
            </summary>
            <remarks>
            This method is useful for situations that ANTLR cannot oridinarily deal 
            with (i.e., when you  create a token based upon a nonliteral token symbol 
            like #[LT(1)].  This is a runtime value and ANTLR cannot determine the token 
            type (and hence the AST) statically.
            </remarks>
            <param name="tokenType">Token type to override.</param>
            <param name="NodeTypeName">
            	Fully qualified AST typename (or null to specify 
            	the factory's default AST type).
            </param>
        </member>
        <member name="M:antlr.ASTFactory.registerFactory(System.Int32,System.String)">
            <summary>
            Register an AST Node Type for a given Token type ID.
            </summary>
            <param name="NodeType">The Token type ID.</param>
            <param name="NodeTypeName">The AST Node Type to register.</param>
        </member>
        <member name="M:antlr.ASTFactory.setTokenTypeASTNodeCreator(System.Int32,antlr.ASTNodeCreator)">
            <summary>
            Register an ASTNodeCreator for a given Token type ID.
            </summary>
            <param name="NodeType">The Token type ID.</param>
            <param name="creator">The creater to register.</param>
        </member>
        <member name="M:antlr.ASTFactory.setASTNodeCreator(antlr.ASTNodeCreator)">
            <summary>
            Register an ASTNodeCreator to be used for creating node by default.
            </summary>
            <param name="creator">The ASTNodeCreator.</param>
        </member>
        <member name="M:antlr.ASTFactory.setMaxNodeType(System.Int32)">
            <summary>
            Pre-expands the internal list of TokenTypeID-to-ASTNodeType mappings
            to the specified size.
            This is primarily a convenience method that can be used to prevent 
            unnecessary and costly re-org of the mappings list.
            </summary>
            <param name="NodeType">Maximum Token Type ID.</param>
        </member>
        <member name="M:antlr.ASTFactory.addASTChild(antlr.ASTPair,antlr.collections.AST)">
            <summary>
            Add a child to the current AST
            </summary>
            <param name="currentAST">The AST to add a child to</param>
            <param name="child">The child AST to be added</param>
        </member>
        <member name="M:antlr.ASTFactory.create">
            <summary>
            Creates a new uninitialized AST node. Since a specific AST Node Type
            wasn't indicated, the new AST node is created using the current default
            AST Node type - <see cref="F:antlr.ASTFactory.defaultASTNodeTypeObject_"/>
            </summary>
            <returns>An uninitialized AST node object.</returns>
        </member>
        <member name="M:antlr.ASTFactory.create(System.Int32)">
            <summary>
            Creates and initializes a new AST node using the specified Token Type ID.
            The <see cref="T:System.Type"/> used for creating this new AST node is 
            determined by the following:
            <list type="bullet">
            	<item>the current TokenTypeID-to-ASTNodeType mapping (if any) or,</item>
            	<item>the <see cref="F:antlr.ASTFactory.defaultASTNodeTypeObject_"/> otherwise</item>
            </list>
            </summary>
            <param name="type">Token type ID to be used to create new AST Node.</param>
            <returns>An initialized AST node object.</returns>
        </member>
        <member name="M:antlr.ASTFactory.create(System.Int32,System.String)">
            <summary>
            Creates and initializes a new AST node using the specified Token Type ID.
            The <see cref="T:System.Type"/> used for creating this new AST node is 
            determined by the following:
            <list type="bullet">
            	<item>the current TokenTypeID-to-ASTNodeType mapping (if any) or,</item>
            	<item>the <see cref="F:antlr.ASTFactory.defaultASTNodeTypeObject_"/> otherwise</item>
            </list>
            </summary>
            <param name="type">Token type ID to be used to create new AST Node.</param>
            <param name="txt">Text for initializing the new AST Node.</param>
            <returns>An initialized AST node object.</returns>
        </member>
        <member name="M:antlr.ASTFactory.create(System.Int32,System.String,System.String)">
            <summary>
            Creates a new AST node using the specified AST Node Type name. Once created,
            the new AST node is initialized with the specified Token type ID and string.
            The <see cref="T:System.Type"/> used for creating this new AST node is 
            determined solely by <c>ASTNodeTypeName</c>.
            The AST Node type must have a default/parameterless constructor.
            </summary>
            <param name="type">Token type ID to be used to create new AST Node.</param>
            <param name="txt">Text for initializing the new AST Node.</param>
            <param name="ASTNodeTypeName">Fully qualified name of the Type to be used for creating the new AST Node.</param>
            <returns>An initialized AST node object.</returns>
        </member>
        <member name="M:antlr.ASTFactory.create(antlr.IToken,System.String)">
            <summary>
            Creates a new AST node using the specified AST Node Type name.
            </summary>
            <param name="tok">Token instance to be used to initialize the new AST Node.</param>
            <param name="ASTNodeTypeName">
            	Fully qualified name of the Type to be used for creating the new AST Node.
            </param>
            <returns>A newly created and initialized AST node object.</returns>
            <remarks>
            Once created, the new AST node is initialized with the specified Token 
            instance. The <see cref="T:System.Type"/> used for creating this new AST 
            node is  determined solely by <c>ASTNodeTypeName</c>.
            <para>The AST Node type must have a default/parameterless constructor.</para>
            </remarks>
        </member>
        <member name="M:antlr.ASTFactory.create(antlr.collections.AST)">
            <summary>
            Creates and initializes a new AST node using the specified AST Node instance.
            the new AST node is initialized with the specified Token type ID and string.
            The <see cref="T:System.Type"/> used for creating this new AST node is 
            determined solely by <c>aNode</c>.
            The AST Node type must have a default/parameterless constructor.
            </summary>
            <param name="aNode">AST Node instance to be used for creating the new AST Node.</param>
            <returns>An initialized AST node object.</returns>
        </member>
        <member name="M:antlr.ASTFactory.create(antlr.IToken)">
            <summary>
            Creates and initializes a new AST node using the specified Token instance.
            The <see cref="T:System.Type"/> used for creating this new AST node is 
            determined by the following:
            <list type="bullet">
            	<item>the current TokenTypeID-to-ASTNodeType mapping (if any) or,</item>
            	<item>the <see cref="F:antlr.ASTFactory.defaultASTNodeTypeObject_"/> otherwise</item>
            </list>
            </summary>
            <param name="tok">Token instance to be used to create new AST Node.</param>
            <returns>An initialized AST node object.</returns>
        </member>
        <member name="M:antlr.ASTFactory.dup(antlr.collections.AST)">
            <summary>
            Returns a copy of the specified AST Node instance. The copy is obtained by
            using the <see cref="T:System.ICloneable"/> method Clone().
            </summary>
            <param name="t">AST Node to copy.</param>
            <returns>An AST Node (or null if <c>t</c> is null).</returns>
        </member>
        <member name="M:antlr.ASTFactory.dupList(antlr.collections.AST)">
            <summary>
            Duplicate AST Node tree rooted at specified AST node and all of it's siblings.
            </summary>
            <param name="t">Root of AST Node tree.</param>
            <returns>Root node of new AST Node tree (or null if <c>t</c> is null).</returns>
        </member>
        <member name="M:antlr.ASTFactory.dupTree(antlr.collections.AST)">
            <summary>
            Duplicate AST Node tree rooted at specified AST node. Ignore it's siblings.
            </summary>
            <param name="t">Root of AST Node tree.</param>
            <returns>Root node of new AST Node tree (or null if <c>t</c> is null).</returns>
        </member>
        <member name="M:antlr.ASTFactory.make(antlr.collections.AST[])">
            <summary>
            Make a tree from a list of nodes.  The first element in the
            array is the root.  If the root is null, then the tree is
            a simple list not a tree.  Handles null children nodes correctly.
            For example, build(a, b, null, c) yields tree (a b c).  build(null,a,b)
            yields tree (nil a b).
            </summary>
            <param name="nodes">List of Nodes.</param>
            <returns>AST Node tree.</returns>
        </member>
        <member name="M:antlr.ASTFactory.make(antlr.collections.impl.ASTArray)">
            <summary>
            Make a tree from a list of nodes, where the nodes are contained
            in an ASTArray object.
            </summary>
            <param name="nodes">List of Nodes.</param>
            <returns>AST Node tree.</returns>
        </member>
        <member name="M:antlr.ASTFactory.makeASTRoot(antlr.ASTPair,antlr.collections.AST)">
            <summary>
            Make an AST the root of current AST.
            </summary>
            <param name="currentAST"></param>
            <param name="root"></param>
        </member>
        <member name="M:antlr.ASTFactory.setASTNodeType(System.String)">
            <summary>
            Sets the global default AST Node Type for this ASTFactory instance.
            This method also attempts to load the <see cref="T:System.Type"/> instance
            for the specified typename.
            </summary>
            <param name="t">Fully qualified AST Node Type name.</param>
        </member>
        <member name="M:antlr.ASTFactory.error(System.String)">
            <summary>
            To change where error messages go, can subclass/override this method
            and then setASTFactory in Parser and TreeParser.  This method removes
            a prior dependency on class antlr.Tool.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:antlr.ASTNodeCreator">
            <summary>
            A creator of AST node instances.
            </summary>
            <remarks>
            <para>
            This class and it's sub-classes exists primarily as an optimization
            of the reflection-based mechanism(s) previously used exclusively to 
            create instances of AST node objects.
            </para>
            <para>
            Parsers and TreeParsers already use the ASTFactory class in ANTLR whenever
            they need to create an AST node objeect. What this class does is to support
            performant extensibility of the basic ASTFactory. The ASTFactory can now be
            extnded as run-time to support more new AST node types without using needing
            to use reflection.
            </para>
            </remarks>
        </member>
        <member name="M:antlr.ASTNodeCreator.Create">
            <summary>
            Constructs an <see cref="T:antlr.collections.AST"/> instance.
            </summary>
        </member>
        <member name="P:antlr.ASTNodeCreator.ASTNodeTypeName">
            <summary>
            Returns the fully qualified name of the AST type that this
            class creates.
            </summary>
        </member>
        <member name="T:antlr.ASTVisitor">
            <summary>
            Summary description for ASTVisitor.
            </summary>
        </member>
        <member name="M:antlr.BaseAST.getNumberOfChildren">
            <summary>
            Get number of children of this node; if leaf, returns 0
            </summary>
            <returns>Number of children</returns>
        </member>
        <member name="T:antlr.InputBuffer">
            <summary>
            Represents a stream of characters fed to the lexer from that can be rewound 
            via mark()/rewind() methods.
            </summary>
            <remarks>
            <para>
            A dynamic array is used to buffer up all the input characters.  Normally,
            "k" characters are stored in the buffer.  More characters may be stored 
            during guess mode (testing syntactic predicate), or when LT(i>k) is referenced.
            Consumption of characters is deferred.  In other words, reading the next
            character is not done by conume(), but deferred until needed by LA or LT.
            </para>
            </remarks>
        </member>
        <member name="F:antlr.ByteBuffer.buf">
            <summary>
            Small buffer used to avoid reading individual chars
            </summary>
        </member>
        <member name="F:antlr.CharBuffer.buf">
            <summary>
            Small buffer used to avoid reading individual chars
            </summary>
        </member>
        <member name="F:antlr.CharScanner.tokenCreator">
            <summary>Used for creating Token instances.</summary>
        </member>
        <member name="F:antlr.CharScanner.cached_LA1">
            <summary>Used for caching lookahead characters.</summary>
        </member>
        <member name="M:antlr.CharScanner.panic(System.String)">
            <summary>
            This method is executed by ANTLR internally when it detected an illegal
            state that cannot be recovered from.
            The previous implementation of this method called <see cref="M:System.Environment.Exit(System.Int32)"/>
            and writes directly to <see cref="P:System.Console.Error"/>, which is usually not 
            appropriate when a translator is embedded into a larger application.
            </summary>
            <param name="s">Error message.</param>
        </member>
        <member name="T:antlr.TokenCreator">
            <summary>
            A creator of Token object instances.
            </summary>
            <remarks>
            <para>
            This class and it's sub-classes exists primarily as an optimization
            of the reflection-based mechanism(s) previously used exclusively to 
            create instances of Token objects.
            </para>
            <para>
            Since Lexers in ANTLR use a single Token type, each TokenCreator can 
            create one class of Token objects (that's why it's not called TokenFactory).
            </para>
            </remarks>
        </member>
        <member name="M:antlr.TokenCreator.Create">
            <summary>
            Constructs a <see cref="T:antlr.Token"/> instance.
            </summary>
        </member>
        <member name="P:antlr.TokenCreator.TokenTypeName">
            <summary>
            Returns the fully qualified name of the Token type that this
            class creates.
            </summary>
        </member>
        <member name="F:antlr.CharScanner.ReflectionBasedTokenCreator.tokenTypeName">
            <summary>
            The fully qualified name of the Token type to create.
            </summary>
        </member>
        <member name="F:antlr.CharScanner.ReflectionBasedTokenCreator.tokenTypeObject">
            <summary>
            Type object used as a template for creating tokens by reflection.
            </summary>
        </member>
        <member name="M:antlr.CharScanner.ReflectionBasedTokenCreator.SetTokenType(System.String)">
            <summary>
            Returns the fully qualified name of the Token type that this
            class creates.
            </summary>
        </member>
        <member name="M:antlr.CharScanner.ReflectionBasedTokenCreator.Create">
            <summary>
            Constructs a <see cref="T:antlr.Token"/> instance.
            </summary>
        </member>
        <member name="P:antlr.CharScanner.ReflectionBasedTokenCreator.TokenTypeName">
            <summary>
            Returns the fully qualified name of the Token type that this
            class creates.
            </summary>
        </member>
        <member name="M:antlr.CommonAST.CommonASTCreator.Create">
            <summary>
            Constructs a <see cref="T:antlr.collections.AST"/> instance.
            </summary>
        </member>
        <member name="P:antlr.CommonAST.CommonASTCreator.ASTNodeTypeName">
            <summary>
            Returns the fully qualified name of the AST type that this
            class creates.
            </summary>
        </member>
        <member name="M:antlr.CommonASTWithHiddenTokens.CommonASTWithHiddenTokensCreator.Create">
            <summary>
            Constructs a <see cref="T:antlr.collections.AST"/> instance.
            </summary>
        </member>
        <member name="P:antlr.CommonASTWithHiddenTokens.CommonASTWithHiddenTokensCreator.ASTNodeTypeName">
            <summary>
            Returns the fully qualified name of the AST type that this
            class creates.
            </summary>
        </member>
        <member name="T:antlr.IToken">
            <summary>
            A token is minimally a token type.  Subclasses can add the text matched
            for the token and line info. 
            </summary>
        </member>
        <member name="M:antlr.CommonToken.CommonTokenCreator.Create">
            <summary>
            Constructs a <see cref="T:antlr.Token"/> instance.
            </summary>
        </member>
        <member name="P:antlr.CommonToken.CommonTokenCreator.TokenTypeName">
            <summary>
            Returns the fully qualified name of the Token type that this
            class creates.
            </summary>
        </member>
        <member name="M:antlr.CommonHiddenStreamToken.CommonHiddenStreamTokenCreator.Create">
            <summary>
            Constructs a <see cref="T:antlr.Token"/> instance.
            </summary>
        </member>
        <member name="P:antlr.CommonHiddenStreamToken.CommonHiddenStreamTokenCreator.TokenTypeName">
            <summary>
            Returns the fully qualified name of the Token type that this
            class creates.
            </summary>
        </member>
        <member name="T:antlr.DumpASTVisitor">
            <summary>
            Summary description for DumpASTVisitor.
            </summary>
            Simple class to dump the contents of an AST to the output 
        </member>
        <member name="M:antlr.Parser.consume">
            <summary>
            
            </summary>
        </member>
        <member name="M:antlr.Parser.panic">
            <summary>
            @deprecated as of 2.7.2. This method calls System.exit() and writes
            directly to stderr, which is usually not appropriate when
            a parser is embedded into a larger application. Since the method is
            <code>static</code>, it cannot be overridden to avoid these problems.
            ANTLR no longer uses this method internally or in generated code.
            </summary>
            
        </member>
        <member name="M:antlr.Parser.setASTFactory(antlr.ASTFactory)">
            <summary>
            Specify an object with support code (shared by Parser and TreeParser.
            Normally, the programmer does not play with this, using 
            <see cref="M:antlr.Parser.setASTNodeClass(System.String)"/> instead.
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:antlr.Parser.setASTNodeClass(System.String)">
            <summary>
            Specify the type of node to create during tree building. 
            </summary>
            <param name="cl">Fully qualified AST Node type name.</param>
        </member>
        <member name="M:antlr.Parser.setASTNodeType(System.String)">
            <summary>
            Specify the type of node to create during tree building. 
            use <see cref="M:antlr.Parser.setASTNodeClass(System.String)"/> now to be consistent with 
            Token Object Type accessor.
            </summary>
            <param name="nodeType">Fully qualified AST Node type name.</param>
        </member>
        <member name="M:antlr.MismatchedCharException.appendCharName(System.Text.StringBuilder,System.Int32)">
            <summary>
            Append a char to the msg buffer.  If special, then show escaped version
            </summary>
            <param name="sb">Message buffer</param>
            <param name="c">Char to append</param>
        </member>
        <member name="M:antlr.ParseTree.getLeftmostDerivationStep(System.Int32)">
            <summary>
            Walk parse tree and return requested number of derivation steps.
            If steps less-than 0, return node text.  If steps equals 1, return derivation
            string at step.
            </summary>
            <param name="step">derivation steps</param>
            <returns></returns>
        </member>
        <member name="M:antlr.ParseTree.getLeftmostDerivation(System.Text.StringBuilder,System.Int32)">
            <summary>
            Get derivation and return how many you did (less than requested for
            subtree roots.
            </summary>
            <param name="buf">string buffer</param>
            <param name="step">derivation steps</param>
            <returns></returns>
        </member>
        <member name="M:antlr.ParseTreeRule.getLeftmostDerivation(System.Text.StringBuilder,System.Int32)">
            <summary>
            Do a step-first walk, building up a buffer of tokens until
            you've reached a particular step and print out any rule subroots
            insteads of descending.
            </summary>
            <param name="buf">derivation buffer</param>
            <param name="step">derivation steps</param>
            <returns></returns>
        </member>
        <member name="T:antlr.TokenStreamRewriteEngine">
            <summary>
            This token stream tracks the *entire* token stream coming from
            a lexer, but does not pass on the whitespace (or whatever else
            you want to discard) to the parser.
            </summary>
            <remarks>
            <para>
            This class can then be asked for the ith token in the input stream.
            Useful for dumping out the input stream exactly after doing some
            augmentation or other manipulations.  Tokens are index from 0..n-1
            </para>
            <para>
            You can insert stuff, replace, and delete chunks.  Note that the
            operations are done lazily--only if you convert the buffer to a
            string.  This is very efficient because you are not moving data around
            all the time.  As the buffer of tokens is converted to strings, the
            toString() method(s) check to see if there is an operation at the
            current index.  If so, the operation is done and then normal string
            rendering continues on the buffer.  This is like having multiple Turing
            machine instruction streams (programs) operating on a single input tape. :)
            </para>
            <para>
            Since the operations are done lazily at toString-time, operations do not
            screw up the token index values.  That is, an insert operation at token
            index i does not change the index values for tokens i+1..n-1.
            </para>
            <para>
            Because operations never actually alter the buffer, you may always get
            the original token stream back without undoing anything.  Since
            the instructions are queued up, you can easily simulate transactions and
            roll back any changes if there is an error just by removing instructions.
            For example,
            </para>
            <example>For example:
            <code>
            TokenStreamRewriteEngine rewriteEngine = new TokenStreamRewriteEngine(lexer);
            JavaRecognizer           parser        = new JavaRecognizer(rewriteEngine);
            ...
            rewriteEngine.insertAfter("pass1", t, "foobar");}
            rewriteEngine.insertAfter("pass2", u, "start");}
            System.Console.Out.WriteLine(rewriteEngine.ToString("pass1"));
            System.Console.Out.WriteLine(rewriteEngine.ToString("pass2"));
            </code>
            </example>
            <para>
            You can also have multiple "instruction streams" and get multiple
            rewrites from a single pass over the input.  Just name the instruction
            streams and use that name again when printing the buffer.  This could be
            useful for generating a C file and also its header file--all from the
            same buffer.
            </para>
            <para>
            If you don't use named rewrite streams, a "default" stream is used.
            </para>
            <para>
            Terence Parr, parrt@cs.usfca.edu
            University of San Francisco
            February 2004
            </para>
            </remarks>
        </member>
        <member name="F:antlr.TokenStreamRewriteEngine.tokens">
            <summary>
            Track the incoming list of tokens
            </summary>
        </member>
        <member name="F:antlr.TokenStreamRewriteEngine.programs">
            <summary>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps string (name) -> rewrite (List)
            </summary>
        </member>
        <member name="F:antlr.TokenStreamRewriteEngine.lastRewriteTokenIndexes">
            <summary>
            Map string (program name) -> Integer index
            </summary>
        </member>
        <member name="F:antlr.TokenStreamRewriteEngine.index">
            <summary>
            track index of tokens
            </summary>
        </member>
        <member name="F:antlr.TokenStreamRewriteEngine.stream">
            <summary>
            Who do we suck tokens from?
            </summary>
        </member>
        <member name="F:antlr.TokenStreamRewriteEngine.discardMask">
            <summary>
            Which (whitespace) token(s) to throw out
            </summary>
        </member>
        <member name="M:antlr.TokenStreamRewriteEngine.rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.
            </summary>
            <remarks>
            UNTESTED!
            </remarks>
            <param name="programName"></param>
            <param name="instructionIndex"></param>
        </member>
        <member name="M:antlr.TokenStreamRewriteEngine.deleteProgram(System.String)">
            <summary>
            Reset the program so that no instructions exist
            </summary>
            <param name="programName"></param>
        </member>
        <member name="M:antlr.TokenStreamRewriteEngine.addToSortedRewriteList(antlr.TokenStreamRewriteEngine.RewriteOperation)">
            <summary>
            If op.index > lastRewriteTokenIndexes, just add to the end.
            Otherwise, do linear
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:antlr.TokenStreamRewriteEngine.RewriteOperation.execute(System.Text.StringBuilder)">
            <summary>
            Execute the rewrite operation by possibly adding to the buffer.
            </summary>
            <param name="buf">rewrite buffer</param>
            <returns>The index of the next token to operate on.</returns>
        </member>
        <member name="T:antlr.TokenWithIndex">
            <summary>
            This token tracks it's own index 0..n-1 relative to the beginning 
            of the stream. It is designed to work with 
            <see cref="T:antlr.TokenStreamRewriteEngine"/> in TokenStreamRewriteEngine.cs
            </summary> 
        </member>
        <member name="F:antlr.TokenWithIndex.index">
            <summary>
            Index into token array indicating position in input stream
            </summary>
        </member>
        <member name="M:antlr.TreeParser.panic">
            <summary>
            @deprecated as of 2.7.2. This method calls System.exit() and writes
            directly to stderr, which is usually not appropriate when
            a parser is embedded into a larger application. Since the method is
            <code>static</code>, it cannot be overridden to avoid these problems.
            ANTLR no longer uses this method internally or in generated code.
            </summary>
            
        </member>
        <member name="T:Castle.Windsor.Configuration.AppDomain.CastleSectionHandler">
            <summary>
            Implementation of <see cref="T:System.Configuration.IConfigurationSectionHandler"/>.
            Do not support configuration inheritance.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.CastleLanguage.NodeBase">
            <summary>
            Summary description for NodeBase.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.CastleLanguage.ImportDirective">
            <summary>
            Summary description for ImportDirective.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.CastleLanguage.ImportDirectiveCollection">
            <summary>
            Summary description for ImportNodeCollection.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.CastleLanguage.NodeCollectionBase">
            <summary>
            Summary description for NodeCollectionBase.
            </summary>
        </member>
        <member name="F:Castle.Windsor.Configuration.Interpreters.CastleLanguage.IndentTokenStream.indentStack">
            The stack of indent levels (column numbers) 
        </member>
        <member name="F:Castle.Windsor.Configuration.Interpreters.CastleLanguage.IndentTokenStream.sp">
            stack pointer 
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.CastleLanguage.IndentTokenStream.FindPreviousIndent(System.Int32)">
            Return the index on stack of previous indent level == i else -1 
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.CastleLanguage.LexicalInfo">
            <summary>
            Summary description for LexicalInfo.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.CastleLanguage.WindsorConfLanguageLexer.mLEADING_WS(System.Boolean)">
              Grab everything before a real symbol.  Then if newline, kill it
              as this is a blank line.  If whitespace followed by comment, kill it
              as it's a comment on a line by itself.
            
              Ignore leading whitespace when nested in [..], (..), {..}.
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.IConfigurationInterpreter">
            <summary>
            Interpreter of a specific language to describe 
            configuration nodes in a hierachical manner.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.IConfigurationInterpreter.Process(Castle.MicroKernel.IConfigurationStore)">
            <summary>
            Implementors should make sure that the 
            Interpreter instance already has a reference 
            to a configuration source.
            </summary>
            <param name="store"></param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.AbstractInterpreter.Process(Castle.MicroKernel.IConfigurationStore)">
            <summary>
            
            </summary>
            <param name="store"></param>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.ConfigLanguageInterpreter">
            <summary>
            
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Interpreters.ConfigLanguageInterpreter.Process(Castle.MicroKernel.IConfigurationStore)">
            <summary>
            
            </summary>
            <param name="store"></param>
        </member>
        <member name="T:Castle.Windsor.Configuration.Interpreters.XmlInterpreter">
            <summary>
            Reads the configuration from a XmlFile. Example structure:
            <code>
            &lt;configuration&gt;
              &lt;facilities&gt;
                &lt;facility id="myfacility"&gt;
                
                &lt;/facility&gt;
              &lt;/facilities&gt;
              
              &lt;components&gt;
                &lt;component id="component1"&gt;
                
                &lt;/component&gt;
              &lt;/components&gt;
            &lt;/configuration&gt;
            </code>
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.IConfigurationSource">
            <summary>
            Abstract a configuration source that might 
            be a file, a config node (CDATA) or a hardcode content.
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Sources.AppDomainConfigSource">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Windsor.Configuration.Sources.StaticContentSource">
            <summary>
            
            </summary>
        </member>
        <member name="M:Castle.Windsor.Configuration.Sources.ManifestResourceSource.AssertValidResource(System.Type)">
            <summary>
            Ensures the resource exists in the manifest.
            </summary>
            <param name="type">The type to scope the resource.</param>
        </member>
        <member name="M:Castle.Windsor.Configuration.Sources.ManifestResourceSource.ExtractResourceStream">
            <summary>
            Extracts the <see cref="T:System.IO.Stream"/> representing the resource.
            </summary>
            <returns>The resource <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="T:Castle.Windsor.Configuration.CascadeConfigurationStore">
            <summary>
            Enables a hierarchical configuration store. 
            </summary>
        </member>
        <member name="T:Castle.Windsor.Installer.DefaultComponentInstaller">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Windsor.IComponentsInstaller">
            <summary>
            Bad name. It also install facilities.
            TODO: Better name!
            </summary>
        </member>
        <member name="T:Castle.Windsor.Proxy.DefaultMethodInvocation">
            <summary>
            This implementation of <see cref="T:Castle.Model.Interceptor.IMethodInvocation"/>
            holds an array of interceptors. When the Proceed method is invoked,
            it just increment the Current index and invoke the next interceptor. 
            </summary>
            <remarks>
            Although we have multithread test cases to ensure the correct 
            behavior, we might have threading synchronization issues.
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultMethodInvocation.#ctor(Castle.DynamicProxy.ICallable,System.Object,System.Reflection.MethodInfo,System.Object)">
            <summary>
            Constructs a DefaultMethodInvocation. This is invoked 
            by the DynamicProxy generated code.
            </summary>
            <param name="callable"></param>
            <param name="proxy"></param>
            <param name="method"></param>
        </member>
        <member name="T:Castle.Windsor.Proxy.DefaultProxyFactory">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> relies 
            on DynamicProxy to expose proxy capabilies.
            </summary>
            <remarks>
            Note that only virtual methods can be intercepted in a 
            concrete class. However, if the component 
            was registered with a service interface, we proxy
            the interface and the methods don't need to be virtual,
            </remarks>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.#ctor">
            <summary>
            Constructs a DefaultProxyFactory
            </summary>
        </member>
        <member name="M:Castle.Windsor.Proxy.DefaultProxyFactory.Create(Castle.MicroKernel.IKernel,Castle.Model.ComponentModel,System.Object[])">
            <summary>
            
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.Proxy.InterceptorChain">
            <summary>
            Represents an ordered chain of <see cref="T:Castle.Model.Interceptor.IMethodInterceptor"/>
            implementations.
            </summary>
        </member>
        <member name="M:Castle.Windsor.Proxy.InterceptorChain.#ctor(Castle.Model.Interceptor.IMethodInterceptor[])">
            <summary>
            
            </summary>
            <param name="interceptors"></param>
        </member>
        <member name="M:Castle.Windsor.Proxy.InterceptorChain.Intercept(Castle.Model.Interceptor.IMethodInvocation,System.Object[])">
            <summary>
            Executes the method Intercept on the chain.
            </summary>
            <param name="invocation"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.Proxy.InterceptorChain.Intercept(Castle.DynamicProxy.IInvocation,System.Object[])">
            <summary>
            This method will rarely be used, however, depending on which
            v-table (ie interface) is being exposed, it might be called, so we handle.
            </summary>
            <param name="invocation"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.Windsor.IContainerAccessor">
            <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <p>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </p>
            </summary>
        </member>
        <member name="T:Castle.Windsor.IWindsorContainer">
            <summary>
            The <c>IWindsorContainer</c> interface exposes all the 
            functionality the Windsor implements.
            </summary>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
            Registers a facility within the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddComponent(System.String,System.Type)">
            <summary>
            Adds a component to be managed by the container
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            Adds a component to be managed by the container
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.String)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Resolve(System.Type)">
            <summary>
            Returns a component instance by the service
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.Release(System.Object)">
            <summary>
            Releases a component instance
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.Windsor.IWindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
            Registers a subcontainer. The components exposed
            by this container will be accessible from subcontainers.
            </summary>
            <param name="childContainer"></param>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Item(System.String)">
            <summary>
            Shortcut to the method <see cref="M:Castle.Windsor.IWindsorContainer.Resolve(System.String)"/>
            </summary>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Item(System.Type)">
            <summary>
            Shortcut to the method <see cref="M:Castle.Windsor.IWindsorContainer.Resolve(System.String)"/>
            </summary>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Kernel">
            <summary>
            Returns the inner instance of the MicroKernel
            </summary>
        </member>
        <member name="P:Castle.Windsor.IWindsorContainer.Parent">
            <summary>
            Gets or sets the parent container if this instance
            is a sub container.
            </summary>
        </member>
        <member name="T:Castle.Windsor.WindsorContainer">
            <summary>
            Implementation of <see cref="T:Castle.Windsor.IWindsorContainer"/>
            which delegates to <see cref="T:Castle.MicroKernel.IKernel"/> implementation.
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor">
            <summary>
            Constructs a container without any external 
            configuration reference
            </summary>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IConfigurationStore)">
            <summary>
            Constructs a container using the specified 
            <see cref="T:Castle.MicroKernel.IConfigurationStore"/> implementation.
            </summary>
            <param name="store"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.Windsor.Configuration.IConfigurationInterpreter)">
            <summary>
            Constructs a container using the specified 
            <see cref="T:Castle.Windsor.Configuration.IConfigurationInterpreter"/> implementation.
            </summary>
            <param name="interpreter"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.#ctor(Castle.MicroKernel.IKernel,Castle.Windsor.IComponentsInstaller)">
            <summary>
            Constructs a container using the specified <see cref="T:Castle.MicroKernel.IKernel"/>
            implementation. Rarely used.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
            Registers a facility within the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddComponent(System.String,System.Type)">
            <summary>
            Adds a component to be managed by the container
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            Adds a component to be managed by the container
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.String)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Resolve(System.Type)">
            <summary>
            Returns a component instance by the service
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Release(System.Object)">
            <summary>
            Releases a component instance
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.AddChildContainer(Castle.Windsor.IWindsorContainer)">
            <summary>
            Registers a subcontainer. The components exposed
            by this container will be accessible from subcontainers.
            </summary>
            <param name="childContainer"></param>
        </member>
        <member name="M:Castle.Windsor.WindsorContainer.Dispose">
            <summary>
            Executes Dispose on underlying <see cref="T:Castle.MicroKernel.IKernel"/>
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Kernel">
            <summary>
            Returns the inner instance of the MicroKernel
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Parent">
            <summary>
            Gets or sets the parent container if this instance
            is a sub container.
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Item(System.String)">
            <summary>
            Shortcut to the method <see cref="M:Castle.Windsor.WindsorContainer.Resolve(System.String)"/>
            </summary>
        </member>
        <member name="P:Castle.Windsor.WindsorContainer.Item(System.Type)">
            <summary>
            Shortcut to the method <see cref="M:Castle.Windsor.WindsorContainer.Resolve(System.String)"/>
            </summary>
        </member>
    </members>
</doc>
