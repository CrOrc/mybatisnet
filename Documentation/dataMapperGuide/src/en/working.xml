<?xml version="1.0" encoding="UTF-8"?>
<chapter id="working">
  <title>Working with Data Maps</title>

  <sect1>
    <title>Introduction</title>

    <para>If you want to know how to configure and install iBATIS, see the
    sections Developer Guide for your platform. But if you want to know how
    iBATIS <emphasis>really</emphasis> works, continue from here.</para>

    <para>The Data Map definition file is where the interesting stuff happens.
    Here, you define how your application interacts with your database. As
    mentioned, the Data Map definition is an XML descriptor file. By using a
    service routine provided by iBATIS, the XML descriptors are rendered into
    a client object (or <classname>Mapper</classname>). To access your Data
    Maps, your application calls the client object and passes in the name of
    the statement you need.</para>

    <para>The real work of using iBATIS is not so much in the application
    code, but in the XML descriptors that iBATIS renders. Instead of monkeying
    with application source code, you monkey with XML descriptors instead. The
    benefit is that the XML descriptors are much better suited to the task of
    mapping your object properties to database entities. At least, that's our
    own experience with our own applications. Of course, your mileage may
    differ.</para>
  </sect1>

  <sect1>
    <title>What's in a Data Map definition file, anyway?</title>

    <para>If you read the Tutorial, you've already seen some simple Data Map
    examples, like the one shown in Example 2.1.<example>
        <title>A simple Data Map (.NET)</title>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
 &lt;sqlMap namespace="LineItem" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:noNamespaceSchemaLocation="SqlMap.xsd"&gt;

  <emphasis role="comment">&lt;!--Type aliases allow you to use a shorter name for long fully qualified class names.--&gt;</emphasis>
  &lt;alias&gt;
    &lt;typeAlias alias="LineItem" type="NPetshop.Domain.Billing.LineItem, NPetshop.Domain" /&gt;
  &lt;/alias&gt;

  &lt;statements&gt;
    &lt;insert id="InsertLineItem" parameterClass="LineItem"&gt;
      INSERT INTO [LinesItem] 
        (Order_Id, LineItem_LineNum, Item_Id, LineItem_Quantity, LineItem_UnitPrice)
      VALUES
       (#Order.Id#, #LineNumber#, #Item.Id#, #Quantity#, #Item.ListPrice#)
    &lt;/insert&gt;
  &lt;/statements&gt;
&lt;/sqlMap&gt;</programlisting>
      </example></para>

    <para>This map takes some properties from a LineItem instance and merges
    the values into the SQL statement. The value-add is that our SQL in
    separated from our program code, and we can pass our LineItem instance
    directly to a library method:</para>

    <para><programlisting>C#
Mapper.Instance().Insert("InsertLineItem",lineItem);</programlisting></para>

    <para>No fuss, no muss. Likewise, see Example 3.2 for a simple select
    statement.</para>

    <para>In Example 3.1, we use SQL aliasing to map columns to our object
    properties and an iBATIS inline parameter (see sidebar) to insert a
    runtime value. Easy as pie.</para>

    <sidebar>
      <para><emphasis> A Quick Glance at Inline Parameters </emphasis></para>

      <para>Say we have a mapped statement element that looks like
      this:</para>

      <programlisting>&lt;statement id="InsertProduct"&gt;
  insert into Products (Product_Id, Product_Description) 
  values (#Id#, #Description#);
&lt;/statement&gt;</programlisting>

      <para>The inline parameters here are #Id# and #Description#. Let's also
      say that we have an object with the properties <parameter>Id</parameter>
      and <parameter>Description</parameter>. If we set the object properties
      to <parameter>5</parameter> and "<parameter>dog</parameter>",
      respectively, and passed the object to the mapped statement, we'd end up
      with a runtime query that looked like this:</para>

      <programlisting>insert into Products (Product_Id, Product_Description) values (5, â€˜dog');</programlisting>

      <para>For more about inline parameters, see Section 3.4.</para>
    </sidebar>

    <para>But, what if you wanted some ice cream with that pie? And maybe a
    cherry on top? What if we wanted to cache the result of the select? Or,
    what if we didn't want to use SQL aliasing or named parameters. (Say,
    because we were using pre-existing SQL that we didn't want to touch.)
    Example 3.2 shows a Data Map that specifies a cache, and uses a
    &lt;parameterMap&gt; and a &lt;resultMap&gt; to keep our SQL
    pristine.</para>

    <para><example>
        <title>A Data Map definition file with some bells and whistles</title>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;sqlMap namespace="Product" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:noNamespaceSchemaLocation="SqlMap.xsd"&gt;

  <emphasis role="alias">&lt;typeAlias alias="Product" type="Example.Domain.Product, Example.Domain" /&gt;</emphasis>

  <emphasis role="cache">&lt;alias&gt;
    &lt;cacheModel id="productCache" type="LRU"&gt;
      &lt;flushInterval hours="24"/&gt;
      &lt;property name="size" value="1000" /&gt;
    &lt;/cacheModel&gt;
  &lt;/alias&gt;</emphasis>

  <emphasis role="resultmap"> &lt;resultMaps&gt;
    &lt;resultMap id="productResult" class="Product"&gt;
      &lt;result property="Id" column="Product_Id"/&gt;
      &lt;result property="Description" column="Product_Description"/&gt;
    &lt;/resultMap&gt;
   &lt;/resultMaps&gt;</emphasis>

  <emphasis role="statement">&lt;statements&gt;
    &lt;select id="GetProduct" parameterMap="productParam" cacheModel="productCache"&gt;
      select * from Products where Product_Id = ?
    &lt;/select&gt;
  &lt;/statements&gt;</emphasis>

  <emphasis role="parameterMap">&lt;parameterMaps&gt;
    &lt;parameterMap id="productParam" class="Product"&gt;
      &lt;parameter property="Id"/&gt;
    &lt;/parameterMap&gt;
  &lt;parameterMaps&gt;</emphasis>

&lt;/sqlMap&gt;</programlisting>
      </example>In Example 3.2, &lt;parameterMap&gt; maps the SQL
    "<parameter>?</parameter>" to the <classname>product</classname>
    <property>Id</property> property. The &lt;resultMap&gt; maps the columns
    to our object properties. The &lt;cacheModel&gt; keeps the result of the
    last one thousand of these queries in active memory for up to 24
    hours.</para>

    <para>Example 3.2 is longer and more complex than Example 3.1, but
    considering what you get in return, it seems like a fair trade. (A bargain
    even.)</para>

    <para>Many <emphasis>agile</emphasis> developers would start with
    something like Example 3.1 and add features like caching later. If you
    changed the Data Map from Example 3.1 to Example 3.2, you would not have
    to touch your application source code at all. You can start simple and add
    complexity only when it is needed.</para>

    <para>A single Data Map definition file can contain as many Cache Models,
    Type Aliases, Result Maps, Parameter Maps, and Mapped Statements
    (including stored procedures), as you like. Everything is loaded into the
    same configuration, so you can define elements in one Data Map and then
    use them in another. Use discretion and organize the statements and maps
    appropriately for your application by finding some logical way to group
    them.</para>
  </sect1>

  <sect1>
    <title>Mapped Statements</title>

    <para>Mapped Statements can hold any SQL statement and can use Parameter
    Maps and Result Maps for input and output. (A stored procedure is a
    specialized form of a statement. See section 3.3.1 and 3.3.2 for
    more.)</para>

    <para>If the case is simple, the Mapped Statement can reference the
    parameter and result classes directly. Mapped Statements support caching
    through reference to a Cache Model element. Example 5 shows the syntax for
    a statement element. <example>
        <title>Statement element syntax</title>

        <programlisting>&lt;statement id="<emphasis role="blue">statement.name</emphasis>"
  [parameterMap="<emphasis role="blue">parameterMap.name</emphasis>"]
  [parameterClass="<emphasis role="blue">alias</emphasis>"]
  [resultMap="<emphasis role="blue">resultMap.name</emphasis>"]
  [resultClass="<emphasis role="blue">class.name|alias</emphasis>"]
  [cacheModel="<emphasis role="blue">cache.name</emphasis>"]
&gt;

  select * from Products where Product_Id = [?|#propertyName#]
  order by [$simpleDynamic$]

&lt;/statement&gt;</programlisting>
      </example></para>

    <para>In Example 3.3, the [bracketed] parts are optional, and some options
    are mutually exclusive. It is perfectly legal to have a Mapped Statement
    as simple as shown by Example 6.<example>
        <title>A simplistic Mapped Statement</title>

        <programlisting>&lt;statement id="InsertTestProduct" &gt;
  insert into Products (Product_Id, Product_Description) values (1, "Shih Tzu")
&lt;/statement&gt;</programlisting>
      </example></para>

    <para>Example 6 is obviously unlikely, unless you are running a test. But
    it does shows that you can use iBATIS to execute arbitrary SQL statements.
    More likely, you will use the object mapping features with Parameter Maps
    (Section 3.4) and Result Maps (Section 3.5), where the magic
    happens.</para>

    <sect2>
      <title>Statement Types</title>

      <para>The &lt;statement&gt; element is a general "catch all" element
      that can be used for any type of SQL statement. Generally it is a good
      idea to use one of the more specific statement-type elements. The more
      specific elements provided better error-checking and even more
      functionality. (For example, the insert statement can return a
      database-generated key.) Table 1 summarizes the statement-type elements
      and their supported attributes and features.</para>

      <para><table>
          <title>The six statement-type elements</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry>Statement Element</entry>

                <entry>Attributes</entry>

                <entry>Child Elements</entry>

                <entry>Methods</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>&lt;statement&gt;</entry>

                <entry><programlisting>id 
parameterClass 
resultClass 
parameterMap 
resultMap 
cacheModel</programlisting></entry>

                <entry><programlisting>All dynamic elements</programlisting></entry>

                <entry><programlisting>Insert 
Update 
Delete 
All query methods</programlisting></entry>
              </row>

              <row>
                <entry>&lt;insert&gt;</entry>

                <entry><programlisting>id 
parameterClass 
parameterMap</programlisting></entry>

                <entry><programlisting>All dynamic elements
&lt;selectKey&gt; 
&lt;generate&gt;</programlisting></entry>

                <entry><programlisting>Insert 
Update 
Delete </programlisting></entry>
              </row>

              <row>
                <entry>&lt;update&gt;</entry>

                <entry><programlisting>id 
parameterClass 
parameterMap</programlisting></entry>

                <entry><programlisting>All dynamic elements 
&lt;generate&gt;</programlisting></entry>

                <entry><programlisting>Insert 
Udate 
Delete</programlisting></entry>
              </row>

              <row>
                <entry>&lt;delete&gt;</entry>

                <entry><programlisting>id 
parameterClass 
parameterMap</programlisting></entry>

                <entry><programlisting>All dynamic elements 
&lt;generate&gt;</programlisting></entry>

                <entry><programlisting>Insert 
Update 
Delete</programlisting></entry>
              </row>

              <row>
                <entry>&lt;select&gt;</entry>

                <entry><programlisting>id 
parameterClass 
resultClass 
parameterMap 
resultMap 
cacheModel</programlisting></entry>

                <entry><programlisting>All dynamic elements 
&lt;generate&gt;</programlisting></entry>

                <entry><programlisting>All query methods</programlisting></entry>
              </row>

              <row>
                <entry>&lt;procedure&gt;</entry>

                <entry><programlisting>id 
parameterClass 
resultClass 
parameterMap 
resultMap</programlisting></entry>

                <entry><programlisting>All dynamic elements </programlisting></entry>

                <entry><programlisting>Insert 
Update 
Delete 
All query methods</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </table>The various attributes used by statement-type elements are
      covered in Section 3.3.4.</para>
    </sect2>

    <sect2>
      <title>Stored Procedures</title>

      <para>iBATIS Data Mapper treats stored procedures as yet another
      statement type. Example 3.5 shows a simple Data Map hosting a stored
      procedure. <example>
          <title>A Data Map using a stored procedure</title>

          <programlisting><emphasis role="comment">&lt;!-- Microsot SQL Server --&gt;</emphasis>
&lt;procedure id="SwapEmailAddresses" parameterMap="swap-params"&gt;
  ps_swap_email_address
&lt;/procedure&gt;
... 
&lt;parameterMap id="swap-params"&gt;
  &lt;parameter property="email1" column="First_Email" /&gt;
  &lt;parameter property="email2" column="Second_Email" /&gt;
&lt;/parameterMap&gt;

<emphasis role="comment">&lt;!-- Oracle with .NET 1.1 System.Data.OracleClient provider --&gt;</emphasis>
&lt;procedure id="InsertCategory" parameterMap="insert-params"&gt;
 prc_InsertCategory
&lt;/procedure&gt;
... 
&lt;parameterMap id="insert-params"&gt;
 &lt;parameter property="Name"       column="p_Category_Name"/&gt;
 &lt;parameter property="GuidString" column="p_Category_Guid" dbType="VarChar"/&gt;
 &lt;parameter property="Id"         column="p_Category_Id"   dbType="Int32"   type="Int"/&gt;
&lt;/parameterMap&gt;

<emphasis role="comment">&lt;!-- Oracle with ODP.NET 9i provider --&gt;</emphasis>
&lt;statement id="InsertAccount" parameterMap="insert-params"&gt;
 call prc_InsertAccount(?, ?, ?, ?)
&lt;/statement&gt;
... 
&lt;parameterMap id="insert-params"&gt;
 &lt;parameter property="Id"           dbType="Int32"/&gt;
 &lt;parameter property="FirstName"    dbType="VarChar2" size="32"/&gt;
 &lt;parameter property="LastName"     dbType="VarChar2" size="32"/&gt;
 &lt;parameter property="EmailAddress" dbType="VarChar2" size="128"/&gt;
&lt;/parameterMap&gt;
</programlisting>
        </example>The idea behind Example 3.5 is that calling the stored
      procedure <database>SwapEmailAddresses</database> would exchange two
      email addresses between two columns in a database table and also in the
      parameter object (a <classname>HashTable</classname>). The parameter
      object is only modified if the parameter mappings mode attribute is set
      to <parameter>InputOutput</parameter> or <parameter>Output</parameter>.
      Otherwise they are left unchanged. Of course, immutable parameter
      objects (e.g. <classname>String</classname>) cannot be modified.<note>
          <para>For .NET, the parameterMap attribute is required. The DBType,
          parameter direction, and size are all auto-discovered by the
          framework (via the CommandBuilder).</para>
        </note></para>
    </sect2>

    <sect2>
      <title>The SQL</title>

      <para>If you are not using stored procedures, the most important part of
      a statement-type element is the SQL. You can use any SQL statement that
      is valid for your database system. Since iBATIS passes the SQL through
      to the standard libraries ( ADO.NET), you can use any statement with
      iBATIS that you could use without iBATIS. You can use whatever functions
      your database system supports, and even send multiple statements, so
      long as your driver or provider supports them.</para>

      <para>If standard, static SQL isn't enough, iBATIS can help you build a
      dynamic SQL statement. See Section 3.5 for more about Dynamic
      SQL.</para>

      <sect3>
        <title>Escaping XML symbols</title>

        <para>Because you are combining SQL and XML in a single document,
        conflicts can occur. The most common conflict is the greater-than and
        less-than symbols (&gt;&lt;). SQL statements use these symbols as
        operators, but they are reserved symbols in XML. A simple solution is
        to <emphasis>escape</emphasis> the SQL statements that uses XML
        reserved symbols within a CDATA element. Example 8
        demonstrates.<example>
            <title>Using CDATA to "escape" SQL code</title>

            <programlisting>&lt;statement id="SelectPersonsByAge" parameterClass="int" resultClass="Person"&gt;
  <emphasis role="comment">&lt;![CDATA[</emphasis> 
     SELECT * FROM PERSON WHERE AGE &gt; #value# <emphasis role="comment">
  ]]&gt;</emphasis>
&lt;/statement&gt;</programlisting>
          </example></para>
      </sect3>

      <sect3>
        <title>Auto-Generated Keys</title>

        <para>Many database systems support auto-generation of primary key
        fields, as a vendor extension. Some vendors pre-generate keys (e.g.
        Oracle), some vendors post-generate keys (e.g. MS-SQL Server and
        MySQL). In either case, you can obtain a pre-generated key using a
        &lt;selectKey&gt; stanza within an &lt;insert&gt; element. Example 9
        shows an &lt;insert&gt; statement for either approach.<example>
            <title>&lt;insert&gt; statements using &lt;selectKey&gt;
            stanzas</title>

            <programlisting><emphasis role="comment">&lt;!â€”Oracle SEQUENCE Example using .NET 1.1 System.Data.OracleClient --&gt;</emphasis> 
&lt;insert id="insertProduct-ORACLE" parameterClass="product"&gt; 
  &lt;selectKey resultClass="int" type="pre" property="Id" &gt; 
     <emphasis role="blue">SELECT STOCKIDSEQUENCE.NEXTVAL AS ID FROM DUAL</emphasis>
  &lt;/selectKey&gt; 
  insert into PRODUCT (PRD_ID,PRD_DESCRIPTION) values (#id#,#description#) 
&lt;/insert&gt;

<emphasis role="comment">&lt;!â€” Microsoft SQL Server IDENTITY Column Example --&gt;</emphasis> 
&lt;insert id="insertProduct-MS-SQL" parameterClass="product"&gt; 
  insert into PRODUCT (PRD_DESCRIPTION)
  values (#description#) 
 &lt;selectKey resultClass="int" type="post" property="id" &gt; 
   <emphasis role="blue">select CAST(@@IDENTITY as int) as value</emphasis>
 &lt;/selectKey&gt;
&lt;/insert&gt;

<emphasis role="comment">&lt;!-- MySQL Example --&gt;</emphasis>
&lt;insert id="insertProduct-MYSQL" parameterClass="product"&gt; 
  insert into PRODUCT (PRD_DESCRIPTION)
  values (#description#) 
 &lt;selectKey resultClass="int" type="post" property="id" &gt; 
   <emphasis role="blue">select LAST_INSERT_ID() as value</emphasis>
 &lt;/selectKey&gt;
&lt;/insert&gt;</programlisting>
          </example></para>
      </sect3>

      <sect3>
        <title>&lt;generate&gt; tag</title>

        <para>You can use iBATIS to execute any SQL statement your application
        requires. When the requirements for a statement are simple and
        obvious, you may not even need to write a SQL statement at all. The
        &lt;generate&gt; tag can be used to create simple SQL statements
        automatically, based on a &lt;parameterMap&gt; element. The four CRUD
        statement types (insert, select, update, and delete) are supported.
        For a select, you can select all or select by a key (or keys). Example
        10 shows an example of generating the usual array of CRUD
        statements.</para>

        <example>
          <title>Creating the "usual suspects" with the &lt;generate&gt;
          tag</title>

          <programlisting>
&lt;parameterMaps&gt;
  &lt;parameterMap id="insert-generate-params"&gt;
    &lt;parameter property="Name" column="Category_Name"/&gt;
    &lt;parameter property="Guid" column="Category_Guid" dbType="UniqueIdentifier"/&gt;    
  &lt;/parameterMap&gt;

  &lt;parameterMap id="update-generate-params" extends="insert-generate-params"&gt;
    &lt;parameter property="Id" column="Category_Id" /&gt;
  &lt;/parameterMap&gt;

  &lt;parameterMap id="delete-generate-params"&gt;
    &lt;parameter property="Id" column="Category_Id" /&gt;
    &lt;parameter property="Name" column="Category_Name"/&gt;
  &lt;/parameterMap&gt;

  &lt;parameterMap id="select-generate-params"&gt;
    &lt;parameter property="Id" column="Category_Id" /&gt;
    &lt;parameter property="Name" column="Category_Name"/&gt;
    &lt;parameter property="Guid" column="Category_Guid" dbType="UniqueIdentifier"/&gt;
  &lt;/parameterMap&gt;

&lt;/parameterMaps&gt;

&lt;statements&gt;

  &lt;update id="UpdateCategoryGenerate" parameterMap="update-generate-params"&gt;
    &lt;generate table="Categories" by="Category_Id"/&gt;
  &lt;/update&gt;

  &lt;delete id="DeleteCategoryGenerate" parameterMap="delete-generate-params"&gt;
    &lt;generate table="Categories" by="Category_Id, Category_Name"/&gt;
  &lt;/delete&gt;

  &lt;select id="SelectByPKCategoryGenerate" resultClass="Category" parameterClass="Category" 
          parameterMap="select-generate-params"&gt;
    &lt;generate table="Categories" by="Category_Id"/&gt; 
  &lt;/select&gt;

  &lt;select id="SelectAllCategoryGenerate" resultClass="Category" 
          parameterMap="select-generate-params"&gt;
    &lt;generate table="Categories" /&gt; 
  &lt;/select&gt;

  &lt;insert id="InsertCategoryGenerate" parameterMap="insert-generate-params"&gt;
    &lt;selectKey property="Id" type="post" resultClass="int"&gt;
      select CAST(@@IDENTITY as int) as value
    &lt;/selectKey&gt;
    &lt;generate table="Categories" /&gt;
  &lt;/insert&gt;

&lt;/statements&gt;</programlisting>
        </example>

        <para><note>
            <para>The SQL is generated when the Data Mapper instance is built,
            so there is no performance impact at execution time.</para>
          </note>The tag generates ANSI SQL, which should work with any
        compliant database. Special types, such as blobs, are not supported,
        and vendor-specific types are also not supported. But, the generate
        tag does keep the simple things simple.</para>

        <important>
          <para>The intended use of the &lt;generate&gt; tag is to save
          developers the trouble of coding mundane SQL statements (and only
          mundane statements). It is not meant as a object-to-relational
          mapping tool. There are many frameworks that provide extensive
          object-to-relational mapping features. The &lt;generate&gt; tag is
          not a replacement for any of those. When the &lt;generate&gt; tag
          does not suit your needs, use a conventional statement
          instead.</para>
        </important>

        <sect4>
          <title>&lt;generate&gt; tag attributes</title>

          <para>The generate tag supports two attributes :</para>

          <table>
            <title>&lt;generate&gt; attributes</title>

            <tgroup cols="3">
              <thead>
                <row>
                  <entry>Attribut</entry>

                  <entry>Description</entry>

                  <entry>Required</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>table</entry>

                  <entry>specifies the table name to use in the SQL
                  statement.</entry>

                  <entry>yes</entry>
                </row>

                <row>
                  <entry>by</entry>

                  <entry>specifies the columns to use in a WHERE
                  clause</entry>

                  <entry>no</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Statement-type Element Attributes</title>

      <para>The six statement-type elements take various attributes. See
      Section 3.2.1 for a table itemizing which attributes each element-type
      accepts. The individual attributes are described in Sections 3.4.1
      through 3.4.5.</para>

      <sect3>
        <title>id</title>

        <para>The required <parameter>id</parameter> attribute provides a name
        for this statement, which must be unique within this
        &lt;SqlMap&gt;.</para>
      </sect3>

      <sect3>
        <title>parameterMap</title>

        <para>A Parameter Map defines an ordered list of values that match up
        with the "<parameter>?</parameter>" placeholders of a standard,
        parameterized query statement. Example 3.9 shows a
        &lt;parameterMap&gt; and a corresponding &lt;statement&gt;.<example>
            <title>A parameterMap and corresponding statement</title>

            <programlisting>&lt;parameterMap id="<emphasis role="blue">insert-product-param</emphasis>" class="product"&gt;
  &lt;parameter property="id"/&gt;
  &lt;parameter property="description"/&gt;
&lt;/parameterMap&gt;

&lt;statement id="insertProduct" parameterMap="<emphasis role="blue">insert-product-param</emphasis>"&gt;
  insert into PRODUCT (PRD_ID, PRD_DESCRIPTION) values (?,?);
&lt;/statement&gt;</programlisting>
          </example></para>

        <para>In Example 3.9, the Parameter Map describes two parameters that
        will match, in order, two placeholders in the SQL statement. The first
        "<parameter>?</parameter>" is replaced by the value of the
        <property>id</property> property. The second is replaced with the
        <property>description</property> property.</para>

        <para>iBATIS also supports named, inline parameters, which most
        developers seem to prefer. However, Parameter Maps are useful when the
        SQL must be kept in a standard form or when extra information needs to
        be provided. For more about Parameter Maps see Section 3.4.</para>
      </sect3>

      <sect3>
        <title>parameterClass</title>

        <para>If a parameterMap attribute is not specified (see Section 3.4),
        you may specify a parameterClass instead and use inline parameters
        (see Section 3.3.3 ). The value of the parameterClass attribute can be
        a Type Alias or the fully qualified name of a class. Example 3.10
        shows a statement using a fully-qualified name versus an
        alias.<example>
            <title>Ways to specify a parameterClass</title>

            <programlisting><emphasis role="comment">&lt;!-- fully qualified classname --&gt;</emphasis>
&lt;statement id="statementName" parameterClass="<emphasis role="blue">Examples.Domain.Product, examples.domain</emphasis>"&gt;
  insert into PRODUCT values (#id#, #description#, #price#)
&lt;/statement&gt;

<emphasis role="comment">&lt;!-- typeAlias (defined elsewhere) --&gt;</emphasis>
&lt;statement id="statementName" parameterClass="<emphasis role="blue">Product</emphasis>"&gt;
  insert into PRODUCT values (#id#, #description#, #price#)
&lt;/statement&gt;</programlisting>
          </example></para>
      </sect3>

      <sect3>
        <title>resultMap</title>

        <para>A Result Map lets you control how data is extracted from the
        result of a query, and how the columns are mapped to object
        properties. Example 3.11 shows a &lt;resultMap&gt; element and a
        corresponding &lt;statement&gt; element.</para>

        <para><example>
            <title>A &lt;resultMap&gt; and corresponding
            &lt;statement&gt;</title>

            <para><programlisting>&lt;resultMap id="<emphasis role="blue">select-product-result</emphasis>" class="product"&gt;
  &lt;result property="id" column="PRD_ID"/&gt;
  &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
&lt;/resultMap&gt;

&lt;statement id="selectProduct" resultMap="<emphasis role="blue">select-product-result</emphasis>"&gt;
  select * from PRODUCT
&lt;/statement&gt;</programlisting></para>

            <para>In Example 3.11, the result of the SQL query will be mapped
            to an instance of the Product class using the
            "select-product-result" &lt;resultMap&gt;. The &lt;resultMap&gt;
            says to populate the <property>id</property> property from the
            <database>PRD_ID</database> column, and to populate the
            <parameter>description</parameter> property from the
            <database>PRD_DESCRIPTION</database> column. <tip>
                <para>In Example 3.11, note that using "<database> select *
                </database>" is supported. If you want all the columns, you
                don't need to map them all individually. (Though many
                developers consider it a good practice to always specify the
                columns expected.)</para>
              </tip></para>

            <para>For more about Result Maps, see Section 3.5.</para>
          </example></para>
      </sect3>

      <sect3>
        <title>resultClass</title>

        <para>If a resultMap is not specified, you may specify a resultClass
        instead. The value of the resultClass attribute can be a Type Alias or
        the fully qualified name of a class. The class specified will be
        automatically mapped to the columns in the result, based on the result
        metadata. Example 14 shows a &lt;statement&gt; element with a
        resultClass attribute.</para>

        <para><example>
            <title>A &lt;statement &gt;element with resultClass
            attribute</title>

            <para><programlisting>&lt;statement id="SelectPerson" parameterClass="int" resultClass="<emphasis
                  role="blue">Person</emphasis>"&gt;
  SELECT
  PER_ID as <emphasis role="blue">Id</emphasis>,
  PER_FIRST_NAME as <emphasis role="blue">FirstName</emphasis>,
  PER_LAST_NAME as <emphasis role="blue">LastNam</emphasis>e,
  PER_BIRTH_DATE as <emphasis role="blue">BirthDate</emphasis>,
  PER_WEIGHT_KG as <emphasis role="blue">WeightInKilograms</emphasis>,
  PER_HEIGHT_M as <emphasis role="blue">HeightInMeters</emphasis>
  FROM PERSON
  WHERE PER_ID = #value#
&lt;/statement&gt;</programlisting></para>
          </example>In Example 3.12, the <classname>Person</classname> class
        has properties including: <property>Id</property>,
        <property>FirstName</property>, <property>LastName</property>,
        <property>BirthDate</property>,
        <property>WeightInKilograms</property>, and
        <property>HeightInMeters</property>. Each of these corresponds with
        the column aliases described by the SQL select statement (using the
        "<database>as</database>" keyword â€“a standard SQL feature). When
        executed, a <classname>Person</classname> object is instantiated and
        populated by matching the object property names to the (aliased)
        column names from the query.</para>

        <para>Using SQL aliases to map columns to properties saves defining a
        &lt;resultMap&gt; element, but there are limitations. There is no way
        to specify the types of the output columns (if necessary), there is no
        way to automatically load related data (complex properties), and there
        is a slight performance consequence (from accessing the result
        metadata). Architecturally, using aliases this way mixes
        <emphasis>database logic</emphasis> with <emphasis>reporting
        logic</emphasis>, making the query harder to read and maintain. You
        can overcome these limitations with an explicit Result Map (Section
        3.5).</para>
      </sect3>

      <sect3>
        <title>cacheModel</title>

        <para>If you want to cache the result of a query, you can specify a
        Cache Model as part of the &lt;statement&gt; element. Example 3.13
        shows a &lt;cacheModel&gt; element and a corresponding
        &lt;statement&gt;.</para>

        <para><example>
            <title>A &lt;cacheModel&gt; element with its corresponding
            &lt;statement&gt;</title>

            <para><programlisting>&lt;cacheModel id="<emphasis role="blue">product-cache</emphasis>" implementation="LRU"&gt;
  &lt;flushInterval hours="24"/&gt;
  &lt;flushOnExecute statement="insertProduct"/&gt;
  &lt;flushOnExecute statement="updateProduct"/&gt;
  &lt;flushOnExecute statement="deleteProduct"/&gt;
  &lt;property name="size" value="1000" /&gt;
&lt;/cacheModel&gt;

&lt;statement id="selectProductList" parameterClass="int" cacheModel="<emphasis
                  role="blue">product-cache</emphasis>"&gt;
  select * from PRODUCT where PRD_CAT_ID = #value#
&lt;/statement&gt;</programlisting></para>

            <para>In Example 3.13, a cache is defined for products that uses a
            LRU reference type and flushes every 24 hours or whenever
            associated update statements are executed. For more about Cache
            Models, see Section 3.8.</para>
          </example></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Parameter Maps and Inline Parameters</title>

    <para>Most SQL statements are useful because we can pass them values at
    runtime. Someone wants a database record with the <database>ID
    42</database>, and we need to merge that <database>ID</database> number
    into a select statement. A list of one or more parameters are passed at
    runtime, and each placeholder is replaced in turn. Simple, but labor
    intensive, since developers spend a lot of time counting symbols to make
    sure everything is in sync.</para>

    <para><note>
        <para>Precedents sections introduce the iBATIS inline parameters,
        which automatically map properties to named parameters. Many, if not
        most, iBATIS developers prefer this approach. But others do prefer to
        stick to the standard, anonymous approach to SQL parameters. Sometimes
        people need to retain the purity of the SQL statements, other times
        because extra information needs to be passed.</para>
      </note></para>

    <para>A Parameter Map defines an ordered list of values that match up with
    the placeholders of a parameterized query statement. While the attributes
    specified by the map still need to be in the correct order, each parameter
    is named. You can populate the underlying class in any order, and the
    Parameter Map ensures each value is passed in the correct order.</para>

    <para><note>
        <para>Dynamic Mapped Statements (Section 3.9) can't use Parameter
        Maps. Being dynamic, the number of parameters will change and defeat
        the purpose of a Parameter Map. Depending on your provider, this may
        hinder your ability to use Dynamic Mapped Statements if your provider
        requires the use of some of the attributes, such as size or scale,
        that a &lt;parameter&gt; provides.</para>
      </note></para>

    <para>Parameter Maps can be provided as an external element and
    <emphasis>inline</emphasis>. Example 3.14 shows an external Parameter
    Map.<example>
        <title>An external Parameter Map</title>

        <programlisting>&lt;parameterMap id="<emphasis role="blue">ParameterMap.name</emphasis>" [class="<emphasis
            role="blue">class.name|typeAlias</emphasis>"]&gt;
  &lt;parameter 
    property ="<emphasis role="blue">property.name</emphasis>" 
    [dbType="<emphasis role="blue">database.type</emphasis>"] 
    [nullValue="<emphasis role="blue">null.value.replacement</emphasis>"] 
    [type="<emphasis role="blue">property.CLR.type</emphasis>"] 
    [column="<emphasis role="blue">column.name</emphasis>"]
    [size="<emphasis role="blue">column.size</emphasis>"] 
    [extends="<emphasis role="blue">parent.parameterMap</emphasis>"]/&gt;
  &lt;parameter ... ... /&gt;
  &lt;parameter ... ... /&gt; 
&lt;/parameterMap&gt;</programlisting>
      </example></para>

    <para>In Example 3.14, the parts in [brackets] are optional. The
    parameterMap element only requires the <parameter>id</parameter>
    attribute. The <parameter>class</parameter> attribute is optional but
    recommended. The <parameter>class</parameter> attribute helps to validate
    the incoming parameter and optimizes performance. Example 3.15 shows a
    typical &lt;parameterMap&gt;. <example>
        <title>A typical &lt;parameterMap&gt; element</title>

        <programlisting>&lt;parameterMap id="insert-product-param" class="product"&gt;
  &lt;parameter property="<emphasis role="blue">description</emphasis>" /&gt;
  &lt;parameter property="<emphasis role="blue">id</emphasis>"/&gt;
  &lt;/parameterMap&gt;

&lt;statement id="insertProduct" parameterMap="insert-product-param"&gt;
  insert into PRODUCT (<emphasis role="blue">PRD_DESCRIPTION</emphasis>, <emphasis
            role="blue">PRD_ID</emphasis>) values (?,?);
&lt;/statement&gt;</programlisting>
      </example></para>

    <para><note>
        <para>Parameter Map names are always local to the Data Map definition
        file where they are defined. You can refer to a Parameter Map in
        another Data Map definition file by prefixing the
        <parameter>id</parameter> of the Parameter Map with the namespace of
        the Data Map (set in the &lt;sqlMap&gt; root tag). If the Parameter
        Map in Example 3.15 were in a Data Map named "Product", it could be
        referenced from another file using
        "Product.insert-product-param".</para>
      </note></para>

    <sect2>
      <title>&lt;parameterMap&gt; attributes</title>

      <para>The &lt;parameterMap&gt; element accepts two attributes:
      <parameter>id</parameter> (required) and <parameter>class</parameter>
      (optional).</para>

      <sect3>
        <title>id</title>

        <para>The required id attribute provides a unique identifier for the
        &lt;parameterMap&gt; within this Data Map.</para>
      </sect3>

      <sect3>
        <title>class</title>

        <para>The optional <parameter>class</parameter> attribute specifies an
        object class to use with this &lt;parameterMap&gt;. The full classname
        or an alias must be specified. Any class can be used.</para>

        <para><note>
            <para>The parameter classes must be a property object or
            <interfacename>IDictionary</interfacename> instance (if you are
            using .NET).</para>
          </note></para>
      </sect3>
    </sect2>

    <sect2>
      <title>&lt;parameter&gt; Elements</title>

      <para>The &lt;parameterMap&gt; element holds one or more parameter
      stanzas that map object properties to placeholders in a SQL statement.
      Section 3.3.2.1 through 3.3.2.11 describe each of the attributes.</para>

      <sect3>
        <title>column</title>

        <para>The <parameter>column</parameter> attribute is used to define to
        the name of a parameter used by a stored procedure.</para>
      </sect3>

      <sect3>
        <title>direction</title>

        <para>The <parameter>direction</parameter> attribute may be used to
        indicate a stored procedure parameter's direction.</para>

        <table>
          <title>Parameter direction attribute values</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry>Value</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Input</entry>

                <entry>input-only</entry>
              </row>

              <row>
                <entry>Output</entry>

                <entry>output-only</entry>
              </row>

              <row>
                <entry>InputOutput</entry>

                <entry>bidirectional</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>

      <sect3>
        <title>extends</title>

        <para>The optional <parameter>extends</parameter> attribute can be set
        to the name of another parameterMap upon which to base this
        parameterMap. All properties of the <emphasis>super</emphasis>
        parameterMap will be included as part of this parameterMap, and values
        from the <emphasis>super</emphasis> parameterMap are set before any
        values specified by this parameterMap. The effect is similar to
        extending a class.</para>
      </sect3>

      <sect3>
        <title>dbType</title>

        <para>The <parameter>dbType</parameter> attribute (.NET) is used to
        explicitly specify the database column type of the parameter to be set
        by this property. For certain operations, some ADO.NET providers are
        not able to determine the type of a column, and the type must be
        specified.</para>

        <para>This attribute is normally only required if the column is
        nullable. Although, another reason to use the type attribute is to
        explicitly specify date types. Whereas .NET only have one Date value
        type (<classname>System.DateTime</classname>), most SQL databases have
        more than one. Usually, a database has at least three different types
        (<database>DATE</database>, <database>DATETIME</database>,
        <database>TIMESTAMP</database>). In order for the value to map
        correctly, you might need to specify the column type,</para>

        <para><note>
            <para>Most providers only need the type specified for nullable
            columns. In this case, you only need to specify the type for the
            columns that are nullable.</para>
          </note><note>
            <para>When using Oracle, you will create an <errortext>Invalid
            column type</errortext> error if you attempt to set a null value
            to a column without specifying its type.</para>
          </note></para>

        <para>The <parameter>dbType</parameter> attribute can be set to any
        string value that matches a constant in the specific data type
         enum of the used provider (<classname>System.Data.SqlDbType</classname> for Microsoft Sql Server). 
		Although it can be set to any of these, some types are not supported
        (<classname>blobs</classname>). Section 3.6 describes the types that
        are supported by the framework.</para>
      </sect3>

      <sect3>
        <title>type</title>

        <para>The <parameter>type</parameter> attribute (.NET) is used to
        specify the CLR type of the parameter's
        <parameter>property</parameter>. This attribute is useful when passing
        InputOutput and Output parameters into stored procedures. The
        framework uses the specified <parameter>type</parameter> to properly
        handle and set the parameter object's properties with the procedure's
        output values after execution.</para>

        <para>Normally, the type can be derived from a property through
        reflection, but certain mappings that use objects such as a Map cannot
        provide the property type to the framework. If the attribute type is
        not set and the framework cannot otherwise determine the type, the
        type is assumed to be an Object. Section 6 details the CLR types and
        available aliases that are supported by the framework.</para>
      </sect3>

      <sect3>
        <title>nullValue</title>

        <para>The <parameter>nullValue</parameter> attribute can be set to any
        valid value (based on property type). The
        <parameter>nullValue</parameter> attribute is used to specify an
        outgoing null value replacement. What this means is that when the
        value is detected in the object property, a <database>NULL</database>
        will be written to the database (the opposite behavior of an inbound
        null value replacement). This allows you to use a
        <emphasis>magic</emphasis> null number in your application for types
        that do not support null values (such as <classname>int</classname>,
        <classname>double</classname>, <classname>float</classname>). When
        these types of properties contain a matching null value (â€“9999), a
        <database>NULL</database> will be written to the database instead of
        the value.</para>
      </sect3>

      <sect3>
        <title>precision</title>

        <para>The <parameter>precision</parameter> attribute is used to set
        the maximum number of digits used to represent the property
        value.</para>
      </sect3>

      <sect3>
        <title>property</title>

        <para>The <parameter>property</parameter> attribute of
        &lt;parameterMap&gt; is the name of an object property
        (<methodname>get</methodname> method) of the parameter object. It may
        also be the name of an entry in a
        <interfacename>IDictionary</interfacename> (.NET). The name can be
        used more than once depending on the number of times it is needed in
        the statement. (In an update, you might set a column that is also part
        of the where clause.)</para>
      </sect3>

      <sect3>
        <title>scale</title>

        <para>The <parameter>scale</parameter> attribute sets the number of
        decimal places used to resolve the property value.</para>
      </sect3>

      <sect3>
        <title>size</title>

        <para>The <parameter>size</parameter> attribute sets the maximum size,
        in bytes, of the data within the column.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Inline Parameter Maps</title>

      <para>If you prefer to use inline parameters (see Sections 3.0 and
      3.4.3), you can add extra type information inline too. The inline
      parameter map syntax lets you embed the property name, the property
      type, and the column type, into a parametrized SQL statement. Example
      3.16, 3.17 shows coded with inline parameters.<example>
          <title>A &lt;statement&gt; using inline parameters</title>

          <para><programlisting>&lt;statement id="insertProduct" parameterClass="product"&gt;
  insert into PRODUCT (PRD_ID, PRD_DESCRIPTION)
  values (<emphasis role="blue">#id#</emphasis>, <emphasis role="blue">#description#</emphasis>);
&lt;/statement&gt;</programlisting></para>
        </example></para>

      <para>Example 3.18 shows how you can declare dbTypes inline.</para>

      <example>
        <title>A &lt;statement&gt; using an inline parameter map with a
        type</title>

        <para><programlisting>&lt;statement id="insertProduct" parameterClass="product"&gt;
  insert into PRODUCT (PRD_ID, PRD_DESCRIPTION)
  values (<emphasis role="blue">#id:int#</emphasis>, <emphasis role="blue">#description:VarChar#</emphasis>);
&lt;/statement&gt;</programlisting></para>
      </example>

      <para>Example 22 shows how you can declare types and null value
      replacements.</para>

      <example>
        <title>A &lt;statement&gt; using an inline parameter map with null
        value replacements</title>

        <programlisting>&lt;statement id="insertProduct" parameterClass="product"&gt;
  insert into PRODUCT (PRD_ID, PRD_DESCRIPTION)
  values (<emphasis role="blue">#id:int:-999999#</emphasis>, <emphasis role="blue">#description:VarChar:NO_ENTRY#</emphasis>);
&lt;/statement&gt;</programlisting>
      </example>

      <para><note>
          <para>When using inline parameters, you cannot specify the null
          value replacement without also specifying the type. You must specify
          both due to the parsing order.</para>
        </note><note>
          <para>For <emphasis>round-trip</emphasis> transparency of null
          values, you must also specify database columns null value
          replacements in your Result Map (see Section 3.5).</para>
        </note><note>
          <para>Inline parameter maps are handy for small jobs, but when there
          are a lot of type descriptors and null value replacements in a
          complex statement, an industrial-strength, external parameterMap can
          be easer.</para>
        </note></para>
    </sect2>

    <sect2>
      <title>Standard Type Parameters</title>

      <para>In practice, you will find that many statements take a single
      parameter, often an <classname>Integer</classname> or a
      <classname>String</classname>. Rather than wrap a single value in
      another object, you can use the standard library object
      (<classname>String</classname>, <classname>Integer</classname>, et
      cetera) as the parameter directly. Example 3.19 shows a statement using
      a standard type parameter. <example>
          <title>A &lt;statement&gt; using standard type parameters</title>

          <programlisting>&lt;statement id="insertProduct" parameterClass="System.Integer"&gt;
  select * from PRODUCT where PRD_ID = <emphasis role="blue">#value#</emphasis>
&lt;/statement&gt;</programlisting>
        </example></para>

      <para>Assuming <database>PRD_ID</database> is a numeric type, when a
      call is made to this Mapped Statement, a standard Integer object can be
      passed in. The <parameter>#value#</parameter> parameter will be replaced
      with the value of the Integer instance. (The name
      <varname>value</varname> is simply a placeholder, you can use another
      moniker if you like.) Result Maps support primitive types as results as
      well. For more information about using primitive types as parameters,
      see Section 3.4, "Result Maps" and the "Programming iBATIS Data Mapper"
      section in the Developers Guide for your platform.</para>

      <para>For your convenience, primitive types are aliased by the
      framework. For example, <classname>int</classname> can be used in place
      of <classname>System.Integer</classname>. For a complete list, see
      Section 3.6, "Supported Types for Parameter Maps and Result
      Maps".</para>
    </sect2>

    <sect2>
      <title>Map or IDictionary Type Parameters</title>

      <para>You can also pass a <interfacename>IDictionary</interfacename>
      instance as a parameter object. This would usually be a
      <classname>HashTable</classname>. Example 3.20 shows a &lt;statement&gt;
      using an <interfacename>IDictionary</interfacename> for a
      parameterClass.</para>

      <para><example>
          <title>A &lt;statement&gt; using a Map or IDictionary for a
          parameterClass</title>

          <programlisting>&lt;statement id="insertProduct" parameterClass="System.Collections.IDictionary"&gt;
  select * from PRODUCT
  where PRD_CAT_ID = <emphasis role="blue">#catId#</emphasis>
  and PRD_CODE = <emphasis role="blue">#code#</emphasis>
&lt;/statement&gt;</programlisting>
        </example></para>

      <para>In Example 24, notice that the SQL in this Mapped Statement looks
      like any other. There is no difference in how the inline parameters are
      used. If a <classname>HashTable</classname> instance is passed, it must
      contain keys named <property>catId</property> and
      <property>code</property>. The values referenced by those keys must be
      of the appropriate type for the column, just as they would be if passed
      from a properties object.</para>

      <para>Result Maps support Map and
      <interfacename>IDictionary</interfacename> types as results too. For
      more information about using <classname>Map</classname> and
      <interfacename>IDictionary</interfacename> types as parameters, see
      Section 3.5, "Result Maps" and "Programming iBATIS Data Mapper" in your
      platform's Developer Guide (Section 5).</para>

      <para>For your convenience, <interfacename>IDictionary</interfacename>
      types are aliased by the framework. So, <classname>map</classname> or
      <classname>HashTable</classname> can be used in place of
      <classname>System.Collections.HashTable</classname>. For a complete list
      of aliases, see Section 3.6, "Supported Types for Parameter Maps and
      Result Maps".</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Result Maps</title>

    <para>Section 3.4 describes Parameter Maps and Inline parameters, which
    map object properties to parameters in a database query. Result Maps
    finish the job by mapping the result of a database query (a set of
    columns) to object properties. Next to Mapped Statements, the Result Map
    is probably one of the most commonly used and most important features to
    understand.</para>

    <para>A Result Map lets you control how data is extracted from the result
    of a query, and how the columns are mapped to object properties. A Result
    Map can describe the column type, a null value replacement, and complex
    property mappings (including Collections). Example 3.21 shows the
    structure of a &lt;resultMap&gt; element.<example>
        <title>The structure of a &lt;resultMap&gt; element.</title>

        <para><programlisting>&lt;resultMap id="<emphasis role="blue">parameterMap.name</emphasis>" 
           [class="<emphasis role="blue">class.name|typeAlias</emphasis>"] 
           [extends="<emphasis role="blue">parent.resultMap</emphasis>"]&gt;

   &lt;result property="<emphasis role="blue">property.name</emphasis>" 
           column="<emphasis role="blue">column.name</emphasis>"
           [columnIndex="<emphasis role="blue">column.index</emphasis>"] 
           [dbType="<emphasis role="blue">database.type</emphasis>"] 
           [type="<emphasis role="blue">CLR.type</emphasis>"]
           [resultMapping="<emphasis role="blue">resultMap.name</emphasis>"]
           [nullValue="<emphasis role="blue">null.value.replacement</emphasis>"] 
           [select="<emphasis role="blue">some.other.statement.name</emphasis>"] 
           [lazyLoad="<emphasis role="blue">true|false</emphasis>"]
   /&gt;
   &lt;result ... .../&gt;
   &lt;result ... .../&gt;

&lt;/resultMap&gt;
</programlisting></para>
      </example>In Example 3.21, the [brackets] indicate optional attributes.
    The <parameter>id</parameter> attribute is required and provides a name
    for the statement to reference. The class attribute is also required, and
    specifies a Type Alias or the fully qualified name of a class. This is the
    class that will be instantiated and populated based on the result mappings
    it contains.</para>

    <para>The resultMap can contain any number of property mappings that map
    object properties to the columns of a result set. The property mappings
    are applied, and the columns are read, in the order that they are defined
    by the element. Mainting the element order ensures consistent results
    between different drivers and providers. <note>
        <para>As with parameter classes, the result class must be a .NET
        object or IDictionary instance (.NET).</para>
      </note></para>

    <sect2>
      <title>Extending resultMaps</title>

      <para>The optional extends attribute can be set to the name of another
      resultMap upon which to base this resultMap. All properties of the
      "super" resultMap will be included as part of this resultMap, and values
      from the "super" resultMap are set before any values specified by this
      resultMap. The effect is similar to extending a class.<tip>
          <para>The "super" resultMap must be defined in the file
          <emphasis>before</emphasis> the extending resultMap. The classes for
          the super and sub resultMaps need not be the same, and do not need
          to be related in any way.</para>
        </tip></para>
    </sect2>

    <sect2>
      <title>&lt;resultMap&gt; attributes</title>

      <para>The &lt;resultMap&gt; element accepts three attributes: id
      (required), class (optional), and extends (optional).</para>

      <sect3>
        <title>id</title>

        <para>The required <parameter>id</parameter> attribute provides a
        unique identifier for the &lt;resultMap&gt; within this Data
        Map.</para>
      </sect3>

      <sect3>
        <title>class</title>

        <para>The optional <parameter>class</parameter> attribute specifies an
        object class to use with this &lt;resultMap&gt;. The full classname or
        an alias must be specified. Any class can be used.</para>

        <para><note>
            <para>As with parameter classes, the result classes must be a .NET
            object or IDictionary instance (.NET).</para>
          </note></para>
      </sect3>

      <sect3>
        <title>extends</title>

        <para>The optional <parameter>extends</parameter> attribute allows the
        result map to inherit all of the properties of the "super" resultMap
        that it extends.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>&lt;result&gt; Elements</title>

      <para>Sections 3.5.* describe the &lt;resultMap&gt; attributes.</para>

      <sect3>
        <title>property</title>

        <para>The <parameter>property</parameter> attribute of the Result Map
        property is the name of a property (get method) of the result object
        that will be returned by the Mapped Statement. The name can be used
        more than once depending on the number of times it is needed to
        populate the results.</para>
      </sect3>

      <sect3>
        <title>column</title>

        <para>The <parameter>column</parameter> attribute value is the name of
        the column in the result set from which the value will be used to
        populate the property.</para>
      </sect3>

      <sect3>
        <title>columnIndex</title>

        <para>As an optional (minimal) performance enhancement, the
        <parameter>columnIndex</parameter> attribute value is the index of the
        column in the ResultSet from which the value will be used to populate
        the object property. This is not likely needed in 99% of applications
        and sacrifices maintainability and readability for speed. Some drivers
        or providers may not realize any performance benefit, while others
        will speed up dramatically.</para>
      </sect3>

      <sect3>
        <title>dbType</title>

        <para>The dbType attribute is used to explicitly specify the database
        column type of the ResultSet column that will be used to populate the
        object property. Although Result Maps do not have the same
        difficulties with null values, specifying the type can be useful for
        certain mapping types such as Date properties. Because an application
        language has one Date value type and SQL databases may have many
        (usually at least 3), specifying the date may become necessary in some
        cases to ensure that dates (or other types) are set correctly.
        Similarly, String types may be populated by a VarChar, Char or CLOB,
        so specifying the type might be needed in those cases too.</para>
      </sect3>

      <sect3>
        <title>type</title>

        <para>The type attribute is used to explicitly specify the CLR
        property type of the parameter to be set. Normally this can be derived
        from a property through reflection, but certain mappings that use
        objects such as a Map cannot provide the type to the framework. If the
        attribute type is not set and the framework cannot otherwise determine
        the type, the type is assumed to be Object. Section 6 details the CLR
        types and available aliases that are supported by the
        framework.</para>
      </sect3>

      <sect3>
        <title>nullValue</title>

        <para>The <parameter>nullValue</parameter> attribute can be set to any
        valid value (based on property type). The
        <parameter>nullValue</parameter> attribute is used to specify an
        outgoing null value replacement. What this means is that when the
        value is detected in the object property, a NULL will be written to
        the database (the opposite behavior of an inbound null value
        replacement). This allows you to use a "magic" null number in your
        application for types that do not support null values (such as
        <classname>int</classname>, <classname>double</classname>,
        <classname>float</classname>). When these types of properties contain
        a matching null value (say, â€“9999), a NULL will be written to the
        database instead of the value.</para>

        <para>If your database has a NULLABLE column, but you want your
        application to represent NULL with a constant value, you can specify
        it in the Result Map as shown in Example 3.22.</para>

        <example>
          <title>Specifying a nullvalue attribute in a Result Map</title>

          <programlisting>&lt;resultMap id="get-product-result" class="product"&gt; 
  &lt;result property="id" column="PRD_ID"/&gt;
  &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
  &lt;result property="subCode" column="PRD_SUB_CODE" <emphasis role="blue">nullValue="-9999"</emphasis>/&gt;
&lt;/resultMap&gt;</programlisting>
        </example>

        <para>In Example 26, if PRD_SUB_CODE is read as NULL, then the subCode
        property will be set to the value of -9999. This allows you to use a
        primitive type in your .NET class to represent a NULLABLE column in
        the database. Remember that if you want this to work for queries as
        well as updates/inserts, you must also specify the nullValue in the
        Parameter Map (discussed earlier in this document).</para>
      </sect3>

      <sect3>
        <title>select</title>

        <para>The select attribute is used to describe a relationship between
        objects and to automatically load complex (i.e. user defined) property
        types. The value of the statement property must be the name of another
        mapped statement. The value of the database column (the column
        attribute) that is defined in the same property element as this
        statement attribute will be passed to the related mapped statement as
        the parameter. Therefore the column must be a supported primitive
        type. More information about supported primitive types and complex
        property mappings/relationships is discussed later in this
        document.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Implicit Result Maps</title>

      <para>If the columns returned by a SQL statement match the result
      object, you may not need an explicit Result Map. If you have control
      over the relational schema, you might be able to name the columns so
      they also work as property names. In Example 3.27, the column names and
      property names already match, so a result map is not needed.<example>
          <title>A Mapped Statement that doesn't need a Result Map</title>

          <programlisting>&lt;statement id="selectProduct" resultClass="product"&gt;
  select
    id,
    description
  from PRODUCT
  where id = #value#
&lt;/statement&gt;</programlisting>
        </example></para>

      <para>Another way to skip a result map is to use column aliasing to make
      the column names match the properties names, as shown in Example
      3.24.</para>

      <example>
        <title>A Mapped Statement using column alaising instead of a Result
        Map</title>

        <programlisting>&lt;statement id="selectProduct" resultClass="product"&gt;
  select
  PRD_ID as <emphasis role="blue">id</emphasis>,
  PRD_DESCRIPTION as <emphasis role="blue">description</emphasis>
  from PRODUCT
  where PRD_ID = #value#
&lt;/statement&gt;</programlisting>
      </example>

      <para>Of course, these techniques will not work if you need to specify a
      column type, a null value, or any other property attributes.</para>

      <para>Case sensitivity can also be an issue with implicit result maps.
      Conceivably, you could have an object with a "FirstName" property and a
      "Firstname" property. When iBATIS tries to match property and column,
      the heurstic is case-insensitive and we cannot guarantee which property
      would match. (Of course, very few developers would have two property
      names that were so simiilar.)</para>

      <para>A final issue is that there is some performance overhead when
      iBATIS has to map the column and property names automatically. The
      difference can be dramatic if using a third-party NET database provider
      with poor support for ResultSetMetaData.</para>
    </sect2>

    <sect2>
      <title>Primitive Results (i.e. String, Integer, Boolean)</title>

      <para>Many times, we don't need to return an object with multiple
      properties. We just need a String, Integer, Boolean, and so forth. If
      you don't need to populate an object, iBATIS can return one of the
      primitive types instead. If you just need the value, you can use a
      standard type as a result class, as shown in Example 3.25.<example>
          <title>Selecting a standard type</title>

          <programlisting>&lt;select id="selectProductCount" resultClass="<emphasis role="blue">System.Int32</emphasis>"&gt;
  select count(1)
  from PRODUCT
&lt;/select&gt;</programlisting>
        </example></para>

      <para>If need be, you can refer to the standard type using a marker
      token, like "value" or "val", as shown by Example 3.26.</para>

      <example>
        <title>Loading a simple list of product descriptions</title>

        <programlisting>&lt;resultMap id="select-product-result" class="System.String"&gt;
  &lt;result property="<emphasis role="blue">value</emphasis>" column="PRD_DESCRIPTION"/&gt;
&lt;/resultMap&gt;</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Maps with ResultMaps</title>

      <para>Instead of a rich object, sometimes all you might need is a simple
      key/value list of the data, where each property is an entry on the list.
      If so, Result Maps can populate a IDictionary instance as easily as
      property objects. The syntax for using a IDictionary is identical to the
      rich object syntax. As shown in Example 3.27, only the result object
      changes.</para>

      <example>
        <title>Result Maps can use generic "entry-type" objects</title>

        <programlisting>&lt;resultMap id="select-product-result" class="<emphasis role="blue">HashTable</emphasis>"&gt;
  &lt;result property="id" column="PRD_ID"/&gt;
  &lt;result property="code" column="PRD_CODE"/&gt;
  &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
  &lt;result property="suggestedPrice" column="PRD_SUGGESTED_PRICE"/&gt;
&lt;/resultMap&gt;</programlisting>
      </example>

      <para>In Example 3.27, an instance of HashTable would be created for
      each row in the result set and populated with the Product data. The
      property name attributes, like <parameter>id</parameter>,
      <parameter>code</parameter>, and so forth, would be the key of the
      entry, and the value of the mapped columns would be the value of the
      entry.</para>

      <para>As shown in Example 3.28, you can also use an implicit Result Map
      with a IDictionary type.</para>

      <example>
        <title>Implicit Result Maps can use "entry-type" objects too</title>

        <para><programlisting>&lt;statement id="selectProductCount" resultClass="<emphasis role="blue">HashTable</emphasis>"&gt;
  select * from PRODUCT
&lt;/statement&gt;</programlisting></para>
      </example>

      <para>What set of entries is returned by Example xx depends on what
      columns are in the result set. If the set of column changes (because
      columns are added or removed), the new set of entries would
      automatically be returned.</para>

      <para><note>
          <para>Certain providers may return column names in upper case
          format. When accessing values with such a provider, you will have to
          pass the Hashtable or HashMap key name in upper case.</para>
        </note></para>
    </sect2>

    <sect2>
      <title>Complex Properties</title>

      <para>In a relational database, one table will often refer to another.
      Likewise, some of your business objects may include another object or
      list of objects. Types that nest other types are called "complex types".
      You may not want a statement to return a simple type, but a fully-formed
      compex type.</para>

      <para>In the database, a related column is usually represented via a 1:1
      relationship, or a 1:M relationship where the class that holds the
      complex property is from the "many side" of the relationship and the
      property itself is from the "one side" of the relationship. The column
      returned from the database will not be the property we want; it is a key
      to be used in another query.</para>

      <para>From the framework's perspective, the problem is not so much
      loading a complex type, but loading each "complex property". To solve
      this problem, you can specify in the Result Map a statement to run to
      load a given property. In Example 33, the "category" property of the
      "select-product-result" element is a complex property. <example>
          <title>A Result Map with a Complex Property</title>

          <programlisting>
&lt;resultMaps&gt;
  &lt;resultMap id="select-product-result" class="product"&gt;
    &lt;result property="id" column="PRD_ID"/&gt;
    &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
    <emphasis role="blue">&lt;result property="category" column="PRD_CAT_ID" select="selectCategory"/&gt;</emphasis>
  &lt;/resultMap&gt;

  &lt;resultMap id="select-category-result" class="category"&gt;
    &lt;result property="id" column="CAT_ID"/&gt;
    &lt;result property="description" column="CAT_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;/resultMaps&gt;

&lt;statements&gt;
  &lt;select id="selectProduct" parameterClass="int" resultMap="select-product-result"&gt;
   select * from PRODUCT where PRD_ID = #value#
  &lt;/select&gt;

  &lt;select id="selectCategory" parameterClass="int" resultMap="select-category-result"&gt;
   <emphasis role="blue">select * from CATEGORY where CAT_ID = #value#</emphasis>
  &lt;/select&gt;
&lt;/statements&gt;
      </programlisting>
        </example> In Example 3.29, the framework will use the
      "selectCategory" statement to populate the "category" property. The
      value of each category is passed to the "selectCategory" statement, and
      the object returned is set to the category property. When the process
      completes, each Product instance will have the the appropriate category
      object instance set.</para>
    </sect2>

    <sect2>
      <title>Avoiding N+1 Selects (1:1)</title>

      <para>A problem with Example 3.29 may be that whenever you load a
      Product, two statements execute: one for the Product and one for the
      Category. For a single Product, this issue may seem trivial. But if you
      load 10 products, then 11 statements execute. For 100 Products, instead
      of one statement product statement executing, a total of 101 statements
      execute. The number of statements executing for Example 3.29 will always
      be N+1: 100+1=101.</para>

      <para>One way to mitigate the problem is to cache the "selectCategory"
      statement . We might have a hundred products, but there might only be
      five categories. Instead of running a SQL query or stored procedure, the
      framework will return the category object from it cache. A 101
      statements would still run, but they would not be hitting the database.
      (See Section 3.8 for more about caches.)</para>

      <para>Another solution is to use a standard SQL join to return the
      columns you need from the another table. A join can bring all the
      columns we need over from the database in a single query. When you have
      a nested object, you can reference nested properties using a dotted
      notation, like "category.description".</para>

      <para>Example 3.30 solves the same problem as Example 3.29, but instead
      uses nested properties uses a join instead.</para>

      <example>
        <title>Resolving complex properties with a join</title>

        <programlisting>
  &lt;resultMap id="select-product-result" class="product"&gt;
    &lt;result property="id" column="PRD_ID"/&gt;
    &lt;result property="description" column="PRD_DESCRIPTION"/&gt;
    <emphasis role="blue">&lt;result property="category" resultMapping="Category.CategoryResult" /&gt;</emphasis>
  &lt;/resultMap&gt;
&lt;/resultMaps&gt;

&lt;statements&gt;
  &lt;statement id="selectProduct" parameterClass="int" resultMap="select-product-result"&gt;
    select *
    from PRODUCT, CATEGORY
    where PRD_CAT_ID=CAT_ID
    and PRD_ID = #value#
  &lt;/statement&gt;
&lt;/statements&gt;
      </programlisting>
      </example>

      <sidebar>
        <para><emphasis>Lazy Loading vs. Joins (1:1)</emphasis></para>

        <para>It's important to note that using a join is not always better.
        If you are in a situation where it is rare to access the related
        object (e.g. the category property of the Product class) then it might
        actually be faster to avoid the join and the unnecessary loading of
        all category properties. This is especially true for database designs
        that involve outer joins or nullable and/or non-indexed columns. In
        these situations it might be better to use the sub-select solution
        with the lazy loading enabled. The general rule of thumb is: use the
        join if you're more likely going to access the associated properties
        than not. Otherwise, only use it if lazy loading is not an
        option.</para>

        <para>If you're having trouble deciding which way to go, don't worry.
        No matter which way you go, you can always change it without impacting
        your application source code. Example 3.29 and 3.40 result in exactly
        the same object graph and are loaded using the exact same method call
        from the application. The only consideration is that if you were to
        enable caching, then the using the separate select (not the join)
        solution could result in a cached instance being returned. But more
        often than not, that won't cause a problem (your application shouldn't
        be dependent on instance level equality i.e. "==").</para>
      </sidebar>
    </sect2>

    <sect2>
      <title>Complex Collection Properties</title>

      <para><remark>[TODO: Revise from 3.5.8 to end of Section
      3]</remark></para>

      <para>It is also possible to load properties that represent lists of
      complex objects. In the database the data would be represented by a M:M
      relationship, or a 1:M relationship where the class containing the list
      is on the "one side" of the relationship and the objects in the list are
      on the "many side". To load a List of objects, there is no change to the
      statement (see example above). The only difference required to cause the
      iBATIS Data Mapper framework to load the property as a List is that the
      property on the business object must be of type
      System.Collections.IList. For example, if a Category has a List of
      Product instances, the mapping would look like this (assume Category has
      a property called "ProductList" of System.Collections.IList.):</para>

      <example>
        <title>Mapping that creates a list of complex objects</title>

        <programlisting>
&lt;resultMaps&gt;

  &lt;resultMap id="select-category-result" class="Category"&gt;
    &lt;result property="Id" column="CAT_ID"/&gt;
    &lt;result property="Description" column="CAT_DESCRIPTION"/&gt;
    <emphasis role="blue">&lt;result property="ProductList" column="CAT_ID" select="selectProductsByCatId"/&gt;</emphasis>
  &lt;/resultMap&gt;

  &lt;resultMap id="select-product-result" class="Product"&gt;
    &lt;result property="Id" column="PRD_ID"/&gt;
    &lt;result property="Description" column="PRD_DESCRIPTION"/&gt;
  &lt;/resultMap&gt;
&lt;resultMaps&gt;

&lt;statements&gt;

  &lt;statement id="selectCategory" parameterClass="int" resultMap="select-category-result"&gt;
    select * from CATEGORY where CAT_ID = #value#
  &lt;/statement&gt;

  &lt;statement id="selectProductsByCatId" parameterClass="int" resultMap="select-product-result"&gt;
    <emphasis role="blue">select * from PRODUCT where PRD_CAT_ID = #value#</emphasis>
  &lt;/statement&gt;
&lt;/statements&gt;</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Avoiding N+1 Selects (1:M and M:N)</title>

      <para>This is similar to the 1:1 situation above, but is of even greater
      concern due to the potentially large amount of data involved. The
      problem with the solution above is that whenever you load a Category,
      two SQL statements are actually being run (one for the Category and one
      for the list of associated Products). This problem seems trivial when
      loading a single Category, but if you were to run a query that loaded
      ten (10) Categories, a separate query would be run for each Category to
      load its associated list of Products. This results in eleven (11)
      queries total: one for the list of Categories and one for each Category
      returned to load each related list of Products (N+1 or in this case
      10+1=11). To make this situation worse, we're dealing with potentially
      large lists of data.</para>

      <para>1:N &amp; M:N Solution? Currently the feature that resolves this
      issue not implemented, but the development discussions are active, and
      we expect it to be included in a future release.</para>

      <sidebar>
        <para><emphasis>Lazy Loading vs. Joins (1:M and M:N)</emphasis></para>

        <para>As with the 1:1 situation described previously, it's important
        to note that using a join is not always better. This is even more true
        for collection properties than it was for individual value properties
        due to the greater amount of data. If you are in a situation where it
        is rare to access the related object (e.g. the ProductList property of
        the Category class) then it might actually be faster to avoid the join
        and the unnecessary loading of the list of products. This is
        especially true for database designs that involve outer joins or
        nullable and/or non-indexed columns. In these situations it might be
        better to use the sub-select solution with the lazy loading. The
        general rule of thumb is: use the join if you're more likely going to
        access the associated properties than not. Otherwise, only use it if
        lazy loading is not an option.</para>

        <para>As mentioned earlier, if you're having trouble deciding which
        way to go, don't worry. No matter which way you go, you can always
        change it without impacting your .NET code. The two examples above
        would result in exactly the same object graph and are loaded using the
        exact same method call. The only consideration is that if you were to
        enable caching, then the using the separate select (not the join)
        solution could result in a cached instance being returned. But more
        often than not, that won't cause a problem (your application should
        not be dependent on instance level equality i.e. "==").</para>
      </sidebar>
    </sect2>

    <sect2>
      <title>Composite Keys or Multiple Complex Parameters Properties</title>

      <para>You might have noticed that in the above examples there is only a
      single key being used as specified in the resultMap by the column
      attribute. This would suggest that only a single column can be
      associated to a related mapped statement. However, there is an alternate
      syntax that allows multiple columns to be passed to the related mapped
      statement. This comes in handy for situations where a composite key
      relationship exists, or even if you simply want to use a parameter of
      some name other than #value#. The alternate syntax for the column
      attribute is simply {param1=column1, param2=column2, â€¦, paramN=columnN}.
      Consider the example below where the PAYMENT table is keyed by both
      Customer ID and Order ID:</para>

      <example>
        <title>Mapping a componsite key</title>

        <programlisting>
&lt;resultMaps&gt;
  &lt;resultMap id="select-order-result" class="order"&gt;
    &lt;result property="id" column="ORD_ID"/&gt;
    &lt;result property="customerId" column="ORD_CST_ID"/&gt;
    ...
    &lt;result property="payments" column="<emphasis role="blue">{itemId=ORD_ID, custId=ORD_CST_ID}</emphasis>"
      select="<emphasis role="blue">selectOrderPayments"</emphasis>/&gt;
  &lt;/resultMap&gt;
&lt;resultMaps&gt;

&lt;statements&gt;

  &lt;statement id="<emphasis role="blue">selectOrderPayments</emphasis>" resultMap="select-payment-result"&gt;
    select * from PAYMENT
    where PAY_ORD_ID = #<emphasis role="blue">itemId</emphasis>#
    and PAY_CST_ID = #<emphasis role="blue">custId</emphasis>#
  &lt;/statement&gt;
&lt;/statements&gt;</programlisting>
      </example>

      <para>Optionally you can just specify the column names as long as
      they're in the same order as the parameters. For example:</para>

      <informalexample>
        <programlisting><emphasis role="blue">{ORD_ID, ORD_CST_ID}</emphasis></programlisting>
      </informalexample>

      <para>As usual, this is a slight performance gain with an impact on
      readability and maintainability.</para>

      <para>Important! Currently the iBATIS Data Mapper framework does not
      automatically resolve circular relationships. Be aware of this when
      implementing parent/child relationships (trees). An easy workaround is
      to simply define a second result map for one of the cases that does not
      load the parent object (or vice versa), or use a join as described in
      the "N+1 avoidance" solutions.<note>
          <para>Result Map names are always local to the Data Map definition
          file that they are defined in. You can refer to a Result Map in
          another Data Map definition file by prefixing the name of the Result
          Map with the namespace of the SQL Map (set in the &lt;sqlMap&gt;
          root tag).</para>
        </note></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Supported Types for Parameter Maps and Result Maps</title>

    <sect2>
      <para>Table 3.3 shows the Supported Types for Parameter Maps and Result
      Maps for .NET. <table><title>Supported Types for Parameter Maps and
      Result Maps (.NET only)</title> <tgroup cols="4"> <thead> <row>
      <entry>CLR Type</entry> <entry>Object/Map Property Mapping</entry>
      <entry>Result Class/Parameter Class**</entry> <entry>Type
      Alias**</entry> </row> </thead> <tbody> <row>
      <entry>System.ArrayList</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>list</entry> </row> <row> <entry>System.Boolean</entry>
      <entry>Yes</entry> <entry>Yes</entry> <entry>Boolean, bool</entry>
      </row> <row> <entry>System.Byte</entry> <entry>Yes</entry>
      <entry>Yes</entry> <entry>Byte, byte</entry> </row> <row>
      <entry>System.Char</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Char, char</entry> </row> <row> <entry>System.DateTime</entry>
      <entry>Yes</entry> <entry>Yes</entry> <entry>dateTime, date</entry>
      </row> <row> <entry>System.Decimal</entry> <entry>Yes</entry>
      <entry>Yes</entry> <entry>Decimal, decimal</entry> </row> <row>
      <entry>System.Double</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Double, double</entry> </row> <row> <entry>System.Guid</entry>
      <entry>Yes</entry> <entry>Yes</entry> <entry>guid</entry> </row> <row>
      <entry>System.Hashtable</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>map, hashmap, hashtable</entry> </row> <row>
      <entry>System.Int16</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Int16, short, Short</entry> </row> <row>
      <entry>System.Int32</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Int32, int, Int, integer, Integer</entry> </row> <row>
      <entry>System.Int64</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Int64, long, Long</entry> </row> <row>
      <entry>System.SByte</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>SByte, sbyte</entry> </row> <row> <entry>System.Single</entry>
      <entry>Yes</entry> <entry>Yes</entry> <entry>Float, float, Single,
      single</entry> </row> <row> <entry>System.String</entry>
      <entry>Yes</entry> <entry>Yes</entry> <entry>String, string</entry>
      </row> <row> <entry>System.TimeSpan</entry> <entry>Yes</entry>
      <entry>Yes</entry> <entry>N/A</entry> </row> <row>
      <entry>System.UInt16</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Short, short</entry> </row> <row> <entry>System.UInt32</entry>
      <entry>Yes</entry> <entry>Yes</entry> <entry>Uint, uint</entry> </row>
      <row> <entry>System.UInt64</entry> <entry>Yes</entry> <entry>Yes</entry>
      <entry>Ulong, ulong</entry> </row> </tbody> </tgroup> </table></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Supported database types for Parameter Maps and Result Maps</title>

    <para>Table 3.4 shows the Supported DbTypes for Parameter Maps and Result
    Maps for .NET.</para>

    <para>The .NET Framework data provider type of a Parameter object is
    inferred from the .NET Framework type of the Value of the Parameter
    object, or from the DbType of the Parameter object. The following table
    shows the inferred Parameter type based on the object passed as the
    Parameter value or the specified DbType. You may specify the type of a
    Parameter in a generic fashion by setting the DbType property of the
    Parameter object to a particular System.Data.DbType specific to your
    database. <table>
        <title>Supported DbTypes for Parameter Maps and Result Maps (.NET
        only)</title>

        <tgroup cols="6">
          <thead>
            <row>
              <entry>CLR Type</entry>

              <entry>iBatis support</entry>

              <entry>SqlDbType</entry>

              <entry>OleDbType</entry>

              <entry>OdbcType</entry>

              <entry>OracleType</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Byte[]</entry>

              <entry>Yes</entry>

              <entry>Binary, Image, VarBinary</entry>

              <entry>Binary, VarBinary</entry>

              <entry>Binary, Image, VarBinary</entry>

              <entry>Raw</entry>
            </row>

            <row>
              <entry>Boolean</entry>

              <entry>Yes</entry>

              <entry>Bit</entry>

              <entry>Boolean</entry>

              <entry>Bit</entry>

              <entry>Byte</entry>
            </row>

            <row>
              <entry>Byte</entry>

              <entry>-</entry>

              <entry>TinyInt</entry>

              <entry>-</entry>

              <entry>TinyInt</entry>

              <entry>Byte</entry>
            </row>

            <row>
              <entry>DateTime</entry>

              <entry>Yes</entry>

              <entry>DateTime, SmallDateTime</entry>

              <entry>Date</entry>

              <entry>Date, DateTime, SmallDateTime, Time</entry>

              <entry>DateTime</entry>
            </row>

            <row>
              <entry>char</entry>

              <entry>Yes</entry>

              <entry>Not supported</entry>

              <entry>Char</entry>

              <entry>Char</entry>

              <entry>Byte</entry>
            </row>

            <row>
              <entry>Decimal</entry>

              <entry>Yes</entry>

              <entry>Decimal, Money, SmallMoney</entry>

              <entry>Decimal, Currency, Numeric</entry>

              <entry>Decimal, Numeric</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Double</entry>

              <entry>Yes</entry>

              <entry>Float</entry>

              <entry>Double</entry>

              <entry>Double</entry>

              <entry>Double</entry>
            </row>

            <row>
              <entry>Guid</entry>

              <entry>Yes</entry>

              <entry>UniqueIdentifier</entry>

              <entry>Guid</entry>

              <entry>UniqueIdentifier</entry>

              <entry>Raw</entry>
            </row>

            <row>
              <entry>Int16</entry>

              <entry>Yes</entry>

              <entry>SmallInt</entry>

              <entry>SmallIInt</entry>

              <entry>SmallInt</entry>

              <entry>Int16</entry>
            </row>

            <row>
              <entry>Int32</entry>

              <entry>Yes</entry>

              <entry>Int</entry>

              <entry>Integer</entry>

              <entry>Int</entry>

              <entry>Int32</entry>
            </row>

            <row>
              <entry>Int64</entry>

              <entry>Yes</entry>

              <entry>BigInt</entry>

              <entry>BigInt</entry>

              <entry>BigInt</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Single</entry>

              <entry>Yes</entry>

              <entry>Real</entry>

              <entry>Single</entry>

              <entry>Real</entry>

              <entry>Float</entry>
            </row>

            <row>
              <entry>String</entry>

              <entry>Yes</entry>

              <entry>Char, Nchar, NVarchar, Text, VarChar</entry>

              <entry>Char, VarChar</entry>

              <entry>Char, NChar, NText, NVarChar, Text, VarChar</entry>

              <entry>NVarChar</entry>
            </row>

            <row>
              <entry>TimeSpan</entry>

              <entry>No</entry>

              <entry>Not supported</entry>

              <entry>DBTime</entry>

              <entry>Time</entry>

              <entry>DateTime</entry>
            </row>

            <row>
              <entry>UInt16</entry>

              <entry>yes</entry>

              <entry>Int</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>UInt16</entry>
            </row>

            <row>
              <entry>UInt32</entry>

              <entry>yes</entry>

              <entry>Decimal</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>UInt32</entry>
            </row>

            <row>
              <entry>UInt64</entry>

              <entry>yes</entry>

              <entry>Decimal</entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>Number</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </sect1>

  <sect1>
    <title>Cache Models</title>

    <para>Some values in a database are know to change more slowly than
    others. To improve performance, many developers like to cache often-used
    data, to avoid making unnecessary trips back to the database. iBATIS
    provides its own caching system, that you configure through a
    &lt;cacheModel&gt; element.</para>

    <para>The results from a query Mapped Statement can be cached simply by
    specifying the cacheModel parameter in the statement tag (seen above). A
    cache model is a configured cache that is defined within your Data Mapper
    configuration file. Cache models are configured using the cacheModel
    element as follows:</para>

    <example>
      <title>Configuation a cache using the Cache Model element</title>

      <programlisting>&lt;cacheModel id="<emphasis role="blue">product-cache</emphasis>" implementation="LRU" &gt;
  &lt;flushInterval hours="24"/&gt;
  &lt;flushOnExecute  statement="insertProduct"/&gt;
  &lt;flushOnExecute  statement="updateProduct"/&gt;
  &lt;flushOnExecute  statement="deleteProduct"/&gt;
  &lt;property name="CacheSize" value="100"/&gt;
&lt;/cacheModel&gt;
</programlisting>
    </example>

    <para>The cache model above will create an instance of a cache named
    "product-cache" that uses a Least Recently Used (LRU) implementation. The
    value of the type attribute is either a fully qualified class name, or an
    alias for one of the included implementations (see below). Based on the
    flush elements specified within the cache model, this cache will be
    flushed every 24 hours. There can be only one flush interval element and
    it can be set using hours, minutes, seconds or milliseconds. In addition
    the cache will be flushed whenever the insertProduct, updateProduct, or
    deleteProduct mapped statements are executed. There can be any number of
    "flush on execute" elements specified for a cache. Some cache
    implementations may need additional properties, such as the â€˜cache-size'
    property demonstrated above. In the case of the LRU cache, the size
    determines the number of entries to store in the cache. Once a cache model
    is configured, you can specify the cache model to be used by a mapped
    statement, for example:</para>

    <example>
      <title>Specifying a Cache Model from a Mapped Statement</title>

      <programlisting>&lt;statement id="getProductList" <emphasis role="blue">cacheModel="product-cache"</emphasis>&gt;
  select * from PRODUCT where PRD_CAT_ID = #value#
&lt;/statement&gt;</programlisting>
    </example>

    <sect2>
      <title>Cache Implementation</title>

      <para>The cache model uses a pluggable framework for supporting
      different types of caches. The implementation is specified in the type
      attribute of the cacheModel element (as discussed above). The class name
      specified must be an implementation of the CacheController interface, or
      one of the four aliases discussed below. Further configuration
      parameters can be passed to the implementation via the property elements
      contained within the body of the cacheModel. Currently there are 3
      implementations included with the .NET distribution. These are as
      follows:</para>
    </sect2>

    <sect2>
      <title>"MEMORY"</title>

      <para>The MEMORY cache implementation uses reference types to manage the
      cache behavior. That is, the garbage collector effectively determines
      what stays in the cache or otherwise. The MEMORY cache is a good choice
      for applications that don't have an identifiable pattern of object
      reuse, or applications where memory is scarce (it will do what it
      can).</para>

      <para>The MEMORY implementation is configured as follows:</para>

      <example>
        <title>Configuring a memory-type cache</title>

        <programlisting>&lt;cacheModel id="product-cache" <emphasis role="blue">implementation="MEMORY"</emphasis> &gt;
  &lt;flushInterval hours="24"/&gt;
  &lt;flushOnExecute  statement="insertProduct"/&gt;
  &lt;flushOnExecute  statement="updateProduct"/&gt;
  &lt;flushOnExecute  statement="deleteProduct"/&gt;
  <emphasis role="blue">&lt;property name="Type" value="WEAK"/&gt;</emphasis>
&lt;/cacheModel&gt;
</programlisting>
      </example>

      <para>Only a single property is recognized by the MEMORY cache
      implementation. This property, named 'reference-type' must be set to a
      value of STRONG, SOFT or WEAK.</para>

      <para>The following table describes the different reference types that
      can be used for a MEMORY cache. <table>
          <title>Reference types that can be used for a MEMORY cache</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>WEAK (default)</entry>

                <entry>This reference type is probably the best choice in most
                cases and is the default if the reference-type is not
                specified. It will increase performance for popular results,
                but it will absolutely release the memory to be used in
                allocating other objects, assuming that the results are not
                currently in use.</entry>
              </row>

              <row>
                <entry>SOFT (Java only)</entry>

                <entry>This reference type will reduce the likelihood of
                running out of memory in case the results are not currently in
                use and the memory is needed for other objects. However, this
                is not the most aggressive reference type in that regard and
                memory still might be allocated and made unavailable for more
                important objects.</entry>
              </row>

              <row>
                <entry>STRONG</entry>

                <entry>This reference type will guarantee that the results
                stay in memory until the cache is explicitly flushed (e.g. by
                time interval or flush on execute). This is ideal for results
                that are: 1) very small, 2) absolutely static, and 3) used
                very often. The advantage is that performance will be very
                good for this particular query. The disadvantage is that if
                the memory used by these results is needed, then it will not
                be released to make room for other objects (possibly more
                important objects).</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>

    <sect2>
      <title>"LRU"</title>

      <para>The LRU cache implementation uses an Least Recently Used algorithm
      to determines how objects are automatically removed from the cache. When
      the cache becomes over full, the object that was accessed least recently
      will be removed from the cache. This way, if there is a particular
      object that is often referred to, it will stay in the cache with the
      least chance of being removed. The LRU cache makes a good choice for
      applications that have patterns of usage where certain objects may be
      popular to one or more users over a longer period of time (e.g.
      navigating back and forth between paginated lists, popular search keys
      etc.).</para>

      <para>The LRU implementation is configured as follows:</para>

      <example>
        <title>Configuring a LRU type cache</title>

        <programlisting>&lt;cacheModel id="product-cache"  <emphasis role="blue">implementation="LRU"</emphasis> &gt;
  &lt;flushInterval hours="24"/&gt;
  &lt;flushOnExecute  statement="insertProduct"/&gt;
  &lt;flushOnExecute  statement="updateProduct"/&gt;
  &lt;flushOnExecute  statement="deleteProduct"/&gt;
   <emphasis role="blue">&lt;property name="CacheSize" value="100"</emphasis>/&gt;
&lt;/cacheModel&gt;
</programlisting>
      </example>

      <para>Only a single property is recognized by the LRU cache
      implementation. This property, named CacheSize must be set to an integer
      value representing the maximum number of objects to hold in the cache at
      once. An important thing to remember here is that an object can be
      anything from a single String instance to an ArrayList of object. So
      take care not to store too much in your cache and risk running out of
      memory!</para>
    </sect2>

    <sect2>
      <title>"FIFO"</title>

      <para>The FIFO cache implementation uses an First In First Out algorithm
      to determines how objects are automatically removed from the cache. When
      the cache becomes over full, the oldest object will be removed from the
      cache. The FIFO cache is good for usage patterns where a particular
      query will be referenced a few times in quick succession, but then
      possibly not for some time later.</para>

      <para>The FIFO implementation is configured as follows:</para>

      <example>
        <title>Configuring a FIFO type cache</title>

        <programlisting>&lt;cacheModel id="product-cache" <emphasis role="blue">implementation="FIFO"</emphasis> &gt;
  &lt;flushInterval hours="24"/&gt;
  &lt;flushOnExecute  statement="insertProduct"/&gt;
  &lt;flushOnExecute  statement="updateProduct"/&gt;
  &lt;flushOnExecute  statement="deleteProduct"/&gt;
  <emphasis role="blue">&lt;property name="CacheSize" value="100"/&gt;</emphasis>
&lt;/cacheModel&gt;
</programlisting>
      </example>

      <para>Only a single property is recognized by the FIFO cache
      implementation. This property, named CacheSize must be set to an integer
      value representing the maximum number of objects to hold in the cache at
      once. An important thing to remember here is that an object can be
      anything from a single String instance to an ArrayList of object. So
      take care not to store too much in your cache and risk running out of
      memory</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Dynamic SQL</title>

    <para>A very common problem with working directly with ADO is dynamic SQL.
    It is normally very difficult to work with SQL statements that change not
    only the values of parameters, but which parameters and columns are
    included at all. The typical solution is usually a mess of conditional
    if-else statements and horrid string concatenations. The desired result is
    often a query by example, where a query can be built to find objects that
    are similar to the example object. The iBATIS Data Mapper API provides a
    relatively elegant solution that can be applied to any mapped statement
    element. Here is a simple example:</para>

    <example>
      <title>A simple dynamic select sttatement, with two possible
      outcomes</title>

      <programlisting>&lt;select id="dynamicGetAccountList" cacheModel="account-cache" parameterClass="Account" resultMap="account-result" &gt;
  <emphasis role="blue">select * from ACCOUNT</emphasis>
    &lt;isGreaterThan prepend="and" property="Id" compareValue="0"&gt;
       <emphasis role="blue">where ACC_ID = #Id#</emphasis>
    &lt;/isGreaterThan&gt;
  <emphasis role="blue">order by ACC_LAST_NAME</emphasis>
&lt;/select&gt;</programlisting>
    </example>

    <para>In the above example, there are two possible statements that could
    be created depending on the state of the Id property of the parameter
    object. If the Id parameter is greater than 0, then the statement will be
    created as follows:</para>

    <informalexample>
      <programlisting>select * from ACCOUNT where ACC_ID = ?</programlisting>
    </informalexample>

    <para>Or if the Id parameter is 0 or less, the statement will look as
    follows.</para>

    <informalexample>
      <programlisting>select * from ACCOUNT</programlisting>
    </informalexample>

    <para>The immediate usefulness of this might not become apparent until a
    more complex situation is encountered. For example, the following is a
    somewhat more complex example.</para>

    <example>
      <title>A complex dynamic select statement, with 16 possible
      outcomes</title>

      <programlisting>&lt;select id="dynamicGetAccountList" parameterClass="Account" resultMap="account-result" &gt;
  <emphasis role="blue">select * from ACCOUNT</emphasis>
    &lt;dynamic prepend="WHERE"&gt;
      &lt;isNotNull prepend="AND" property="FirstName"&gt;
        <emphasis role="blue">(ACC_FIRST_NAME = #FirstName#</emphasis>
        &lt;isNotNull prepend="OR" property="LastName"&gt;
          <emphasis role="blue">ACC_LAST_NAME = #LastName#</emphasis>
        &lt;/isNotNull&gt;
        )
    &lt;/isNotNull&gt;
    &lt;isNotNull prepend="AND" property="EmailAddress"&gt;
      <emphasis role="blue">ACC_EMAIL like #EmailAddress#</emphasis>
    &lt;/isNotNull&gt;
    &lt;isGreaterThan prepend="AND" property="Id" compareValue="0"&gt;
      <emphasis role="blue">ACC_ID = #Id#</emphasis>
    &lt;/isGreaterThan&gt;
  &lt;/dynamic&gt;
  <emphasis role="blue">order by ACC_LAST_NAME</emphasis>
&lt;/select&gt;</programlisting>
    </example>

    <para>Depending on the situation, there could be as many as 16 different
    SQL queries generated from the above dynamic statement. To code the
    if-else structures and string concatenations could get quite messy and
    require hundreds of lines of code.</para>

    <para>Using dynamic statements is as simple as inserting some conditional
    tags around the dynamic parts of your SQL. For example:</para>

    <example>
      <title>Creating a dynamic statement with conditional tags</title>

      <para><programlisting>&lt;statement id="someName" parameterClass="Account" resultMap="account-result" &gt;
  select * from ACCOUNT
 <emphasis role="blue"> &lt;dynamic prepend="where"&gt;</emphasis>
    <emphasis role="blue">&lt;isGreaterThan prepend="and" property="id" compareValue="0"&gt;</emphasis>
      ACC_ID = #id#
   <emphasis role="blue"> &lt;/isGreaterThan&gt;</emphasis>
    <emphasis role="blue">&lt;isNotNull prepend="and" property="lastName"&gt;</emphasis>
      ACC_LAST_NAME = #lastName#
    <emphasis role="blue">&lt;/isNotNull&gt;</emphasis>
  <emphasis role="blue">&lt;/dynamic&gt;</emphasis>
order by ACC_LAST_NAME
&lt;/statement&gt;</programlisting></para>
    </example>

    <para>In the above statement, the &lt;dynamic&gt; element demarcates a
    section of the SQL that is dynamic. The dynamic element is optional and
    provides a way to manage a prepend in cases where the prepend (e.g.
    "WHERE") should not be included unless the contained conditions append to
    the statement. The statement section can contain any number of conditional
    elements (see below) that will determine whether a the contained SQL code
    will be included in the statement. All of the conditional elements work
    based on the state of the parameter object passed into the query. Both the
    dynamic element and the conditional elements have a "prepend" attribute.
    The prepend attribute is a part of the code that is free to be overridden
    by the a parent element's prepend if necessary. In the above example the
    "where" prepend will override the first true conditional prepend. This is
    necessary to ensure that the SQL statement is built properly. For example,
    in the case of the first true condition, there is no need for the AND, and
    in fact it would break the statement. The following sections describe the
    various kinds of elements, including Binary Conditionals, Unary
    Conditionals, and Iterate.</para>

    <sect2>
      <title>Binary Conditional Elements</title>

      <para>Binary conditional elements compare a property value to a static
      value or another property value. If the result is true, the body content
      is included in the SQL query.</para>

      <sect3>
        <title>Binary Conditional Attributes:</title>

        <simplelist>
          <member>prepend â€“ the overridable SQL part that will be prepended to
          the statement (optional)</member>

          <member>property â€“ the property to be compared (required)</member>

          <member>compareProperty â€“ the other property to be compared
          (required or compareValue)</member>

          <member>compareValue â€“ the value to be compared (required or
          compareProperty)</member>
        </simplelist>

        <table>
          <title>Binary conditional attributes</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry>Element</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>&lt;isEqual&gt;</entry>

                <entry>Checks the equality of a property and a value, or
                another property. Example Usage:<programlisting>&lt;isEqual prepend="AND" 
             property="status" 
             compareValue="Y"&gt;
MARRIED = â€˜TRUE'
&lt;/isEqual&gt;               </programlisting></entry>
              </row>

              <row>
                <entry>&lt;isNotEqual&gt;</entry>

                <entry>Checks the inequality of a property and a value, or
                another property. Example Usage:<programlisting>&lt;isNotEqual prepend="AND" 
             property="status" 
             compareValue="N"&gt;
MARRIED = â€˜FALSE'
&lt;/isNotEqual&gt;   </programlisting></entry>
              </row>

              <row>
                <entry>&lt;isGreaterThan&gt;</entry>

                <entry>Checks if a property is greater than a value or another
                property. Example Usage:<programlisting>&lt;isGreaterThan prepend="AND" 
             property="age" 
             compareValue="18"&gt;
ADOLESCENT = â€˜FALSE'
&lt;/isGreaterThan&gt;   </programlisting></entry>
              </row>

              <row>
                <entry>&lt;isGreaterEqual&gt;</entry>

                <entry>Checks if a property is greater than or equal to a
                value or another property. Example Usage:<programlisting>&lt;isGreaterEqual prepend="AND" 
             property="shoeSize" 
             compareValue="12"&gt;
BIGFOOT = â€˜TRUE'
&lt;/isGreaterEqual&gt;</programlisting></entry>
              </row>

              <row>
                <entry>&lt;isLessEqual&gt;</entry>

                <entry>Checks if a property is less than or equal to a value
                or another property. Example Usage: <programlisting>&lt;isLessEqual prepend="AND" 
             property="age" 
             compareValue="18"&gt;
ADOLESCENT = â€˜TRUE'
&lt;/isLessEqual&gt;</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>
    </sect2>

    <sect2>
      <title>Unary Conditional Elements</title>

      <para>Unary conditional elements check the state of a property for a
      specific condition.</para>

      <sect3>
        <title>Unary Conditional Attributes:</title>

        <simplelist>
          <member>prepend â€“ the overridable SQL part that will be prepended to
          the statement (optional)</member>

          <member>property â€“ the property to be checked (required)</member>
        </simplelist>

        <table>
          <title>Unary conditional attributes</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry>Element</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>&lt;isPropertyAvailable&gt;</entry>

                <entry>Checks if a property is available (i.e is a property of
                the parameter object). Example Usage: <programlisting>&lt;isPropertyAvailable property="id" &gt;
  ACCOUNT_ID=#id# 
&lt;/isPropertyAvailable&gt;</programlisting></entry>
              </row>

              <row>
                <entry>&lt;isNotPropertyAvailable&gt;</entry>

                <entry>Checks if a property is unavailable (i.e not a property
                of the parameter object). Example Usage: <programlisting>&lt;isNotPropertyAvailable property="age" &gt;
  STATUS='New' 
&lt;/isNotEmpty&gt;</programlisting></entry>
              </row>

              <row>
                <entry>&lt;isNull&gt;</entry>

                <entry>Checks if a property is null. Example Usage:
                <programlisting>&lt;isNull prepend="AND" property="order.id" &gt;
  ACCOUNT.ACCOUNT_ID = ORDER.ACCOUNT_ID(+) 
&lt;/isNotEmpty&gt;</programlisting></entry>
              </row>

              <row>
                <entry>&lt;isNotNull&gt;</entry>

                <entry>Checks if a property is not null. Example Usage:
                <programlisting>&lt;isNotNull prepend="AND" property="order.id" &gt;
  ORDER.ORDER_ID = #order.id#
&lt;/isNotEmpty&gt;</programlisting></entry>
              </row>

              <row>
                <entry>&lt;isEmpty&gt;</entry>

                <entry>Checks to see if the value of a Collection, String
                property is null or empty ("" or size() &lt; 1). Example
                Usage: <programlisting>&lt;isEmpty property="firstName" &gt;
  LIMIT 0, 20
&lt;/isNotEmpty&gt;</programlisting></entry>
              </row>

              <row>
                <entry>&lt;isNotEmpty&gt;</entry>

                <entry>Checks to see if the value of a Collection, String
                property is not null and not empty ("" or size() &lt; 1).
                Example Usage: <programlisting>&lt;isNotEmpty prepend="AND" property="firstName" &gt;
  FIRST_NAME LIKE '%$FirstName$%'
&lt;/isNotEmpty&gt;</programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>
    </sect2>

    <sect2>
      <title>Parameter Present Elements</title>

      <para>These elements check for parameter object existence.</para>

      <sect3>
        <title>Parameter Present Attributes:</title>

        <para>prepend â€“ the overridable SQL part that will be prepended to the
        statement (optional)<table>
            <title>Testing to see if a parameter is present</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Element</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>&lt;isParameterPresent&gt;</entry>

                  <entry>Checks to see if the parameter object is present (not
                  null).<programlisting>&lt;isParameterPresent prepend="AND"&gt;
  EMPLOYEE_TYPE = #empType#
&lt;/isParameterPresent&gt;</programlisting></entry>
                </row>

                <row>
                  <entry>&lt;isNotParameterPresent&gt;</entry>

                  <entry>Checks to see if the parameter object is not present
                  (null). Example Usage:<programlisting>&lt;isNotParameterPresent prepend="AND"&gt;
  EMPLOYEE_TYPE = â€˜DEFAULT'
&lt;/isNotParameterPresent&gt;</programlisting></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </sect3>
    </sect2>

    <sect2>
      <title>Iterate Element</title>

      <para>This tag will iterate over a collection and repeat the body
      content for each item in a List</para>

      <sect3>
        <title>Iterate Attributes:</title>

        <simplelist>
          <member>prepend â€“ the overridable SQL part that will be prepended to
          the statement (optional)</member>

          <member>property â€“ a property of type java.util.List that is to be
          iterated over (required)</member>

          <member>open â€“ the string with which to open the entire block of
          iterations, useful for brackets (optional)</member>

          <member>close â€“ the string with which to close the entire block of
          iterations, useful for brackets (optional)</member>

          <member>conjunction â€“ the string to be applied in between each
          iteration, useful for AND and OR (optional)</member>
        </simplelist>

        <para><table>
            <title>Creating a list of conditional clauses</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Element</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>&lt;iterate&gt;</entry>

                  <entry>Iterates over a property that is of type
                  java.util.List Example Usage:<programlisting>&lt;iterate prepend="AND" property="UserNameList"
  open="(" close=")" conjunction="OR"&gt;
  username=<emphasis role="blue">#userNameList[]#</emphasis>
&lt;/iterate&gt;</programlisting>Note: It is very important to include the
                  square brackets[] at the end of the List property name when
                  using the Iterate element. These brackets distinguish this
                  object as an List to keep the parser from simply outputting
                  the List as a string.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </sect3>
    </sect2>

    <sect2>
      <title>Simple Dynamic SQL Elements</title>

      <para>Despite the power of the full Dynamic Mapped Statement API
      discussed above, sometimes you just need a simple, small piece of your
      SQL to be dynamic. For this, SQL statements and statements can contain
      simple dynamic SQL elements to help implement dynamic order by clauses,
      dynamic select columns or pretty much any part of the SQL statement. The
      concept works much like inline parameter maps, but uses a slightly
      different syntax. Consider the following example:</para>

      <example>
        <title>A dynamic element that changes the collating order</title>

        <para><programlisting>&lt;statement id="getProduct" resultMap="get-product-result"&gt;
  select * from PRODUCT order by <emphasis role="blue">$preferredOrder$</emphasis>
&lt;/statement&gt;</programlisting></para>
      </example>

      <para>In the above example the preferredOrder dynamic element will be
      replaced by the value of the preferredOrder property of the parameter
      object (just like a parameter map). The difference is that this is a
      fundamental change to the SQL statement itself, which is much more
      serious than simply setting a parameter value. A mistake made in a
      Dynamic SQL Element can introduce security, performance and stability
      risks. Take care to do a lot of redundant checks to ensure that the
      simple dynamic SQL elements are being used appropriately. Also, be
      mindful of your design, as there is potential for database specifics to
      encroach on your business object model. For example, you may not want a
      column name intended for an order by clause to end up as a property in
      your business object, or as a field value on your server page.</para>

      <para>Simple dynamic elements can be included within &lt;statements&gt;
      and come in handy when there is a need to modify the SQL statement
      itself. For example:</para>

      <example>
        <title>A dynamic element that changes the comparison operator</title>

        <programlisting>
&lt;statement id="getProduct" resultMap="get-product-result"&gt;
  SELECT * FROM PRODUCT
  &lt;dynamic prepend="WHERE"&gt;
    &lt;isNotEmpty property="Description"&gt;
       PRD_DESCRIPTION <emphasis role="blue">$operator$</emphasis> #Description#
    &lt;/isNotEmpty&gt;
  &lt;/dynamic&gt;
&lt;/statement&gt;</programlisting>
      </example>

      <para>In the above example the operator property of the parameter object
      will be used to replace the $operator$ token. So if the operator
      property was equal to â€˜like' and the description property was equal to
      â€˜%dog%', then the SQL statement generated would be:</para>

      <informalexample>
        <programlisting>  SELECT * FROM PRODUCT WHERE PRD_DESCRIPTION <emphasis role="blue">LIKE</emphasis> â€˜%dog%'</programlisting>
      </informalexample>
    </sect2>
  </sect1>
</chapter>